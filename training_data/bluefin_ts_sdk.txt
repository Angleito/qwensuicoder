import {
  ADJUST_MARGIN,
  BaseWallet,
  bigNumber,
  createZkSignature,
  DAPIKlineResponse,
  DecodeJWT,
  Ed25519Keypair,
  ExtendedWalletContextState,
  getKeyPairFromPvtKey,
  isEmpty,
  MARGIN_TYPE,
  MarketSymbol,
  Order,
  OrderSigner,
  ORDER_SIDE,
  ORDER_STATUS,
  ORDER_TYPE,
  PartialZkLoginSignature,
  Secp256k1Keypair,
  SIGNER_TYPES,
  SigPK,
  SuiClient,
  TIME_IN_FORCE,
  toBaseNumber,
  toBigNumber,
  toBigNumberStr,
  Transaction,
  TransactionBlock,
  TRANSFERABLE_COINS,
  usdcToBaseNumber,
  ZkPayload,
  SuiBlocks,
  SuiTransactionBlockResponse,
} from "@firefly-exchange/library-sui/dist";
import { SignaturePayload } from "@firefly-exchange/library-sui/dist/src/blv/interface";

import {
  toBase64,
  fromBase64,
} from "@firefly-exchange/library-sui/dist/src/blv/utils";

import {
  Keypair,
  parseSerializedSignature,
  Signer,
} from "@mysten/sui/cryptography";
import { SignatureScheme } from "@mysten/sui/src/cryptography/signature-scheme";
import { publicKeyFromRawBytes } from "@mysten/sui/verify";
import { genAddressSeed, getZkLoginSignature } from "@mysten/zklogin";
import { sha256 } from "@noble/hashes/sha256";
import {
  combineAndEncode,
  generateRandomNumber,
  throwCustomError,
} from "../utils/utils";
import {
  Errors,
  Networks,
  POST_ORDER_BASE,
  USER_REJECTED_MESSAGE,
} from "./constants";
import { APIService } from "./exchange/apiService";
import { SERVICE_URLS, VAULT_URLS } from "./exchange/apiUrls";
import {
  ResponseSchema,
  VaultTVLInterval,
} from "./exchange/contractErrorHandling.service";
import { ContractCalls } from "./exchange/contractService";
import { InteractorCalls } from "./exchange/interactorService";
import { Sockets } from "./exchange/sockets";
import { WebSockets } from "./exchange/WebSocket";
import {
  adjustLeverageRequest,
  AdjustLeverageResponse,
  AuthorizeHashResponse,
  BatchClaimPayload,
  CancelOrderResponse,
  ConfigResponse,
  ExchangeInfo,
  Expired1CTSubAccountsResponse,
  ExtendedNetwork,
  GenerateReferralCodeRequest,
  GenerateReferralCodeResponse,
  GetAccountDataResponse,
  GetAffiliatePayoutsResponse,
  GetAffiliateRefereeCountResponse,
  GetAffiliateRefereeDetailsRequest,
  GetAffiliateRefereeDetailsResponse,
  GetCampaignDetailsResponse,
  GetCampaignRewardsResponse,
  GetCandleStickRequest,
  GetCountDownsResponse,
  GetFundingHistoryRequest,
  GetFundingRateResponse,
  GetMakerRewardDetailsRequest,
  GetMakerRewardDetailsResponse,
  GetMakerRewardsSummaryResponse,
  GetMarketRecentTradesRequest,
  GetMarketRecentTradesResponse,
  GetOffchainSettlementUpdatesRequest,
  GetOffchainSettlementUpdatesResponse,
  GetOrderbookRequest,
  GetOrderBookResponse,
  GetOrderRequest,
  GetOrderResponse,
  GetPositionRequest,
  GetPositionResponse,
  GetReferrerInfoResponse,
  GetTotalHistoricalTradingRewardsResponse,
  GetTradeAndEarnRewardsDetailRequest,
  GetTradeAndEarnRewardsDetailResponse,
  GetTradeAndEarnRewardsOverviewResponse,
  GetTransactionHistoryRequest,
  GetTransferHistoryRequest,
  GetUserFundingHistoryResponse,
  GetUserRewardsHistoryRequest,
  GetUserRewardsHistoryResponse,
  GetUserRewardsSummaryResponse,
  GetUserTradesHistoryRequest,
  GetUserTradesHistoryResponse,
  GetUserTradesRequest,
  GetUserTradesResponse,
  GetUserTransactionHistoryResponse,
  GetUserTransferHistoryResponse,
  GetUserWhiteListStatusForMarketMakerResponse,
  IVaultsTVLDatapointsMap,
  LinkReferredUserRequest,
  LinkReferredUserResponse,
  MarketData,
  MarketMeta,
  MasterInfo,
  OpenReferralDetails,
  OpenReferralOverview,
  OpenReferralPayoutList,
  OpenReferralRefereeDetails,
  OrderCancellationRequest,
  OrderCancelSignatureRequest,
  OrderSignatureRequest,
  OrderSignatureResponse,
  PlaceOrderRequest,
  PlaceOrderResponse,
  PostOrderRequest,
  PostTimerAttributes,
  PostTimerResponse,
  SignedSubAccountRequest,
  SponsorTxResponse,
  StatusResponse,
  SubAccountRequest,
  SubAccountResponse,
  TickerData,
  UserPendingWithdrawRequest,
  UserVaultDetail,
  UserVaultDetailSummary,
  VaultDetail,
  VerifyWalletStatusResponse,
} from "./interfaces/routes";
import { debug } from "console";

export class BluefinClient {
  protected readonly network: ExtendedNetwork;

  private orderSigner: OrderSigner;

  private apiService: APIService;

  public sockets: Sockets;

  public webSockets: WebSockets | undefined;

  public vaultConfig: any;

  public marketSymbols: string[] = []; // to save array market symbols [DOT-PERP, SOL-PERP]

  private walletAddress = ""; // to save user's public address when connecting from UI

  private signer: Signer; // to save signer when connecting from UI

  private uiWallet: BaseWallet | any; // to save signer when connecting from UI

  private isZkLogin: boolean = false;

  private contractCalls: ContractCalls | undefined;

  private interactorCalls: InteractorCalls | undefined;

  private provider: SuiClient | undefined; // to save raw web3 provider when connecting from UI

  private isTermAccepted = false;

  private maxSaltLimit = 2 ** 60;

  // the number of decimals supported by USDC contract
  private MarginTokenPrecision = 6;

  private maxEpoch: number;

  private proof: PartialZkLoginSignature;

  private decodedJWT: DecodeJWT;

  private salt: string;

  private is_wallet_extension: boolean = false;

  /**
   * initializes the class instance
   * @param _isTermAccepted boolean indicating if exchange terms and conditions are accepted
   * @param _network containing network rpc url and chain id
   * @param _account accepts either privateKey or AWS-KMS-SIGNER object if user intend to sign using kms
   * @param _scheme signature scheme to be used
   * @param _isUI (optional) is initialized from UI
   * @param _uiWalletType (optional) wallet type connected on the UI i.e SUI, Nightly etc
   */
  constructor(
    _isTermAccepted: boolean,
    _network: ExtendedNetwork,
    _account?: string | Signer,
    _scheme?: SignatureScheme,
    _isUI?: boolean,
    _uiWalletType?: string,
    _uiSignerObject?: any
  ) {
    this.network = _network;

    this.provider = new SuiClient({ url: _network.url });

    this.apiService = new APIService(
      this.network.apiGateway,
      _uiWalletType,
      _network
    );

    this.sockets = new Sockets(this.network.socketURL);
    if (this.network.webSocketURL) {
      this.webSockets = new WebSockets(this.network.webSocketURL);
    }

    this.isTermAccepted = _isTermAccepted;

    if (_account && _scheme && typeof _account === "string") {
      if (_account.split(" ")[1]) {
        // can split with a space then its seed phrase
        this.initializeWithSeed(_account, _scheme);
      } else if (!_account.split(" ")[1]) {
        // splitting with a space gives undefined then its a private key
        const keyPair = getKeyPairFromPvtKey(_account, _scheme);
        this.initializeWithKeyPair(keyPair);
      }
    } else if (
      _account &&
      (_account instanceof Secp256k1Keypair ||
        _account instanceof Ed25519Keypair)
    ) {
      this.initializeWithKeyPair(_account);
    }
    // In case of KMS Signer any of the above condition doesn't matches,
    else if (_account) {
      this.initializeWithKeyPair(_account as Signer);
    }
  }

  /**
   * @description
   * initializes the required objects
   * @param userOnboarding boolean indicating if user onboarding is required
   * @param deployment
   */
  init = async (
    userOnboarding: boolean = true,
    deployment: any = null,
    apiToken = ""
  ) => {
    try {
      if (apiToken) {
        this.apiService.setWalletAddress(this.getPublicAddress());

        this.apiService.setApiToken(apiToken);
        // for socket
        this.sockets.setApiToken(apiToken);
        this.webSockets?.setApiToken(apiToken);
      } else {
        if (!this.signer) {
          throw Error("Signer not initialized");
        }
        await this.initContractCalls(deployment);
        // for BLV contract calls
        await this.initInteractorCalls();

        this.walletAddress = this.isZkLogin
          ? this.walletAddress
          : this.signer.toSuiAddress
          ? this.signer.toSuiAddress()
          : (this.signer as any as ExtendedWalletContextState).getAddress
          ? (this.signer as any as ExtendedWalletContextState).getAddress()
          : this.walletAddress;

        // onboard user if not onboarded
        if (userOnboarding) {
          await this.userOnBoarding();
        }
      }

      if (this.network.UUID) {
        this.setUUID(this.network.UUID);
      }
    } catch (error) {
      throw throwCustomError({
        error,
        code: Errors.FAILED_TO_INITIALIZE_CLIENT,
      });
    }
  };

  initializeWithHook = async (
    uiSignerObject: ExtendedWalletContextState,
    walletAddress: string
  ): Promise<void> => {
    try {
      this.uiWallet = uiSignerObject;
      this.signer = uiSignerObject as any;
      this.walletAddress = walletAddress;
      this.isZkLogin = false;
      this.is_wallet_extension = true;
    } catch (error) {
      throw throwCustomError({
        error,
        code: Errors.FAILED_TO_INITIALIZE_CLIENT_FOR_UI_WALLET,
      });
    }
  };

  initializeForZkLogin = ({
    _account,
    walletAddress,
    maxEpoch,
    proof,
    decodedJWT,
    salt,
  }: {
    _account: string;
    walletAddress: string;
    maxEpoch: number;
    salt: string;
    proof: PartialZkLoginSignature;
    decodedJWT: DecodeJWT;
  }) => {
    try {
      const keyPair = getKeyPairFromPvtKey(_account, "ZkLogin");
      this.signer = keyPair;
      this.walletAddress = walletAddress;
      this.maxEpoch = maxEpoch;
      this.decodedJWT = decodedJWT;
      this.proof = proof;
      this.salt = salt;
      this.isZkLogin = true;
      this.is_wallet_extension = false;
    } catch (error) {
      throw throwCustomError({
        error,
        code: Errors.FAILED_TO_INITIALIZE_CLIENT_FOR_ZK_ACCOUNT,
      });
    }
  };

  /** *
   * Set UUID to api headers for colocation partners
   */
  setUUID = (uuid: string) => {
    this.apiService.setUUID(uuid);
  };

  /**
   * @description
   * initializes web3 and wallet with the given account private key
   * @param keypair key pair for the account to be used for placing orders
   */
  initializeWithKeyPair = async (keypair: Signer): Promise<void> => {
    this.signer = keypair;
    this.walletAddress = this.signer.toSuiAddress();
    this.initOrderSigner(keypair);
  };

  /**
   * @description
   * initializes web3 and wallet with the given account private key
   * @param seed seed for the account to be used for placing orders
   * @param scheme signature scheme to be used
   * @returns void
   */
  initializeWithSeed = (seed: string, scheme: any): void => {
    switch (scheme) {
      case "ED25519":
        this.signer = Ed25519Keypair.deriveKeypair(seed);
        this.initOrderSigner(Ed25519Keypair.deriveKeypair(seed));
        break;
      case "Secp256k1":
        this.signer = Secp256k1Keypair.deriveKeypair(seed);
        this.initOrderSigner(Secp256k1Keypair.deriveKeypair(seed));
        break;
      default:
        throw new Error("Provided scheme is invalid");
    }
  };

  /**
   * @description
   * initializes contract calls
   * @param deployment (optional) The deployment json provided by deployer
   */
  initContractCalls = async (deployment?: any) => {
    if (!this.signer) {
      throw Error("Signer not Initialized");
    }
    const _deployment = deployment || (await this.getDeploymentJson());

    this.contractCalls = new ContractCalls(
      this.getSigner(),
      _deployment,
      this.provider,
      this.isZkLogin,
      this.getZkPayload(),
      this.walletAddress,
      this.is_wallet_extension
    );
  };

  /**
   * @description
   * initializes contract calls
   * @param deployment (optional) The deployment json provided by deployer
   */
  initInteractorCalls = async () => {
    if (!this.signer) {
      throw Error("Signer not Initialized");
    }
    const _deployment = await this.getVaultConfigsForInteractor();
    this.vaultConfig = _deployment;
    this.interactorCalls = new InteractorCalls(
      this.getSigner(),
      _deployment,
      this.provider,
      this.is_wallet_extension,
      this.isZkLogin,
      this.getZkPayload(),
      this.walletAddress
    );
  };

  /**
   * @description
   * Gets the RawSigner of the client
   * @returns RawSigner
   * */
  getSigner = (): Signer => {
    if (!this.signer) {
      throw Error("Signer not initialized");
    }
    return this.signer;
  };

  /**
   * @description
   * Gets the RPC Provider of the client
   * @returns JsonRPCProvider
   * */
  getProvider = (): SuiClient => {
    return this.provider;
  };

  /**
   * Generate and receive readOnlyToken, this can only be accessed at the time of generation
   * @returns readOnlyToken string
   */
  generateReadOnlyToken = async () => {
    const response = await this.apiService.post<string>(
      SERVICE_URLS.USER.GENERATE_READONLY_TOKEN,
      {},
      { isAuthenticationRequired: true }
    );
    return response;
  };

  /**
   * @description
   * Creates message to be signed, creates signature and authorize it from dapi
   * @returns auth token
   */
  userOnBoarding = async (
    token?: string,
    useDeprecatedSigningMethod?: boolean
  ) => {
    this.apiService.setWalletAddress(this.getPublicAddress()); //setting before auth call
    let userAuthToken = token;
    if (!userAuthToken) {
      const signature = await this.createOnboardingSignature({
        useDeprecatedSigningMethod,
      });
      // authorize signature created by dAPI
      const authTokenResponse = await this.authorizeSignedHash(signature);

      if (!authTokenResponse.ok || !authTokenResponse.data) {
        throw Error(
          `Authorization error: ${authTokenResponse.response.message} sig: ${signature}`
        );
      }
      userAuthToken = authTokenResponse.data.token;
    }

    // for api
    this.apiService.setAuthToken(userAuthToken);
    // for socket
    this.sockets.setAuthToken(userAuthToken);
    this.webSockets?.setAuthToken(userAuthToken);
    // TODO: remove this when all endpoints on frontend are integrated from client library
    return userAuthToken;
  };

  createZkSignature({
    userSignature,
    zkPayload,
  }: {
    userSignature: string;
    zkPayload: ZkPayload;
  }) {
    const { salt, decodedJWT, proof, maxEpoch } = zkPayload;
    const addressSeed: string = genAddressSeed(
      BigInt(salt!),
      "sub",
      decodedJWT.sub,
      decodedJWT.aud
    ).toString();

    const zkLoginSignature: string = getZkLoginSignature({
      inputs: {
        ...proof,
        addressSeed,
      },
      maxEpoch,
      userSignature,
    });

    return zkLoginSignature;
  }

  getZkPayload = (): ZkPayload => {
    return {
      decodedJWT: this.decodedJWT,
      proof: this.proof,
      salt: this.salt,
      maxEpoch: this.maxEpoch,
    };
  };

  createOnboardingSignature = async ({
    useDeprecatedSigningMethod,
  }: {
    useDeprecatedSigningMethod?: boolean;
  }) => {
    let signature: SigPK;

    const onboardingSignature = {
      onboardingUrl: this.network.onboardingUrl,
    };

    if (this.uiWallet) {
      try {
        console.log(`[TempLog] createOnboardingSignature: NORMAL WALLET`);
        signature = await OrderSigner.signPayloadUsingWallet(
          onboardingSignature,
          this.uiWallet,
          useDeprecatedSigningMethod
        );
      } catch (error) {
        throwCustomError({ error, code: Errors.WALLET_PAYLOAD_SIGNING_FAILED });
      }
    } else if (this.isZkLogin) {
      try {
        console.log(`[TempLog] createOnboardingSignature: ZK Login`);
        signature = await OrderSigner.signPayloadUsingZKSignature({
          payload: onboardingSignature,
          signer: this.signer,
          zkPayload: this.getZkPayload(),
        });
      } catch (error) {
        throwCustomError({ error, code: Errors.ZK_PAYLOAD_SIGNING_FAILED });
      }
    } else {
      try {
        console.log(`[TempLog] createOnboardingSignature: In ELSE Block`);
        signature = await this.orderSigner.signPayload(onboardingSignature);
      } catch (error) {
        throwCustomError({
          error,
          code: Errors.KEYPAIR_PAYLOAD_SIGNING_FAILED,
        });
      }
    }
    return `${signature?.signature}${
      signature?.publicAddress ? signature?.publicAddress : signature?.publicKey
    }`;
  };

  /**
   * @description
   * Gets the payload containing key and mesasge to sign
   * @returns SigPK
   * */

  signPayloadUsingZkWallet = async (payload: object): Promise<SigPK> => {
    const signature = await OrderSigner.signPayloadUsingZKSignature({
      payload,
      signer: this.signer,
      zkPayload: this.getZkPayload(),
    });

    return signature;
  };

  /**
   * @description
   * Gets the payload containing bytes mesasge to sign
   * @returns SigPK
   * */

  signBytesPayloadUsingZkWallet = async (
    payload: Uint8Array
  ): Promise<SigPK> => {
    const signature = await OrderSigner.signBytesPayloadUsingZKSignature({
      payload,
      signer: this.signer,
      zkPayload: this.getZkPayload(),
    });

    return signature;
  };

  /**
   * @description
   * Gets the wallets Public address
   * @returns string
   * */
  getPublicAddress = (): string => {
    if (!this.signer) {
      Error("Signer not initialized");
    }
    return this.walletAddress;
  };

  parseAndShapeSignedData = ({
    signature,
    isParsingRequired = true,
  }: {
    signature: string;
    isParsingRequired?: boolean;
  }): SigPK => {
    let data: SigPK;
    const parsedSignature = parseSerializedSignature(signature);
    if (isParsingRequired && parsedSignature.signatureScheme === "ZkLogin") {
      // zk login signature
      const { userSignature } = parsedSignature.zkLogin;

      // convert user sig to b64
      const convertedUserSignature = toBase64(userSignature as any);

      // reparse b64 converted user sig
      const parsedUserSignature = parseSerializedSignature(
        convertedUserSignature
      );

      data = {
        signature: `${Buffer.from(parsedSignature.signature).toString("hex")}3`,
        publicKey: publicKeyFromRawBytes(
          parsedUserSignature.signatureScheme,
          parsedUserSignature.publicKey
        ).toBase64(),
      };
    } else {
      data = {
        signature:
          Buffer.from(parsedSignature.signature).toString("hex") +
          SIGNER_TYPES.UI_ED25519,
        publicKey: publicKeyFromRawBytes(
          parsedSignature.signatureScheme,
          parsedSignature.publicKey
        ).toBase64(),
      };
    }
    return data;
  };

  signOrder = async (orderToSign: Order): Promise<SigPK> => {
    let signature: SigPK;
    if (this.uiWallet) {
      signature = await OrderSigner.signOrderUsingWallet(
        orderToSign,
        this.uiWallet
      );
    } else if (this.isZkLogin) {
      signature = await OrderSigner.signOrderUsingZkSignature({
        order: orderToSign,
        signer: this.signer,
        zkPayload: this.getZkPayload(),
      });
    } else if (this.orderSigner.signOrder)
      signature = await this.orderSigner.signOrder(orderToSign);
    else
      throw Error(
        "On of OrderSigner or uiWallet needs to be initialized before signing order "
      );
    return signature;
  };

  /**
   * @description
   * Gets a signed order from the client
   * @returns OrderSignatureResponse
   * @param order OrderSignatureRequest
   * */
  createSignedOrder = async (
    order: OrderSignatureRequest,
    parentAddress?: string
  ): Promise<OrderSignatureResponse> => {
    if (!this.orderSigner && !this.uiWallet && !this.isZkLogin) {
      throw Error("Order Signer not initialized");
    }
    const orderToSign: Order = this.createOrderToSign(order, parentAddress);
    let signature: SigPK;
    try {
      signature = await this.signOrder(orderToSign);
    } catch (e) {
      throw Error("Failed to Sign Order: User Rejected Signature");
    }

    const signedOrder: OrderSignatureResponse = {
      symbol: order.symbol,
      price: order.price,
      quantity: order.quantity,
      side: order.side,
      orderType: order.orderType,
      triggerPrice:
        order.orderType === ORDER_TYPE.STOP_MARKET ||
        order.orderType === ORDER_TYPE.STOP_LIMIT ||
        order.orderType === ORDER_TYPE.STOP_LOSS_LIMIT ||
        order.orderType === ORDER_TYPE.TAKE_PROFIT_LIMIT ||
        order.orderType === ORDER_TYPE.STOP_LOSS_MARKET ||
        order.orderType === ORDER_TYPE.TAKE_PROFIT_MARKET
          ? order.triggerPrice || 0
          : 0,
      postOnly: orderToSign.postOnly,
      cancelOnRevert: orderToSign.cancelOnRevert,
      leverage: toBaseNumber(orderToSign.leverage),
      reduceOnly: orderToSign.reduceOnly,
      salt: Number(orderToSign.salt),
      expiration: Number(orderToSign.expiration),
      maker: orderToSign.maker,
      orderSignature: `${signature?.signature}${
        signature?.publicAddress
          ? signature?.publicAddress
          : signature?.publicKey
      }`,
      orderbookOnly: orderToSign.orderbookOnly,
      timeInForce: order.timeInForce || TIME_IN_FORCE.GOOD_TILL_TIME,
    };
    return signedOrder;
  };

  /**
   * @description
   * Places a signed order on bluefin exchange
   * @param params PlaceOrderRequest containing the signed order created using createSignedOrder
   * @returns PlaceOrderResponse containing status and data. If status is not 201, order placement failed.
   */
  placeSignedOrder = async (params: PlaceOrderRequest) => {
    const response = await this.apiService.post<PlaceOrderResponse>(
      SERVICE_URLS.ORDERS.ORDERS,
      {
        symbol: params.symbol,
        userAddress: params.maker,
        orderType: params.orderType,
        price: toBigNumberStr(params.price),
        triggerPrice: toBigNumberStr(
          params.triggerPrice || "0",
          POST_ORDER_BASE
        ),
        quantity: toBigNumberStr(params.quantity),
        leverage: toBigNumberStr(params.leverage),
        side: params.side,
        reduceOnly: params.reduceOnly,
        salt: params.salt,
        expiration: params.expiration,
        orderSignature: params.orderSignature,
        timeInForce: params.timeInForce || TIME_IN_FORCE.GOOD_TILL_TIME,
        orderbookOnly: true,
        postOnly: params.postOnly == true,
        cancelOnRevert: params.cancelOnRevert == true,
        clientId: params.clientId
          ? `bluefin-client: ${params.clientId}`
          : "bluefin-client",
      },
      { isAuthenticationRequired: true }
    );

    return response;
  };

  /**
   * @description
   * Given an order payload, signs it on chain and submits to exchange for placement
   * @param params PostOrderRequest
   * @returns PlaceOrderResponse
   */
  postOrder = async (params: PostOrderRequest) => {
    if (params.reduceOnly) {
      console.warn(
        "Warning: Reduce Only feature is deprecated until further notice. Reduce Only orders will be rejected from the API."
      );
    }
    const signedOrder = await this.createSignedOrder(
      params,
      params.parentAddress
    );
    const response = await this.placeSignedOrder({
      ...signedOrder,
      timeInForce: params.timeInForce,
      postOnly: params.postOnly == true,
      cancelOnRevert: params.cancelOnRevert == true,
      clientId: params.clientId,
      orderbookOnly: true,
    });

    return response;
  };

  /**
   * @description
   * Creates signature for cancelling orders
   * @param params OrderCancelSignatureRequest containing market symbol and order hashes to be cancelled
   * @returns generated signature string
   */
  createOrderCancellationSignature = async (
    params: OrderCancelSignatureRequest
  ): Promise<string> => {
    // TODO: serialize correctly, this is the default method from suiet wallet docs
    // const serialized = new TextEncoder().encode(JSON.stringify(params));
    // return this.signer.signData(serialized);
    try {
      let signature: SigPK;

      // taking the hash of list of hashes of cancel signature
      const hashOfHash = Buffer.from(
        sha256(JSON.stringify(params.hashes))
      ).toString("hex");
      const payloadValue: string[] = [];
      payloadValue.push(hashOfHash);
      if (this.uiWallet) {
        // connected via UI
        signature = await OrderSigner.signPayloadUsingWallet(
          { orderHashes: payloadValue },
          this.uiWallet
        );
      } else if (this.isZkLogin) {
        signature = await OrderSigner.signPayloadUsingZKSignature({
          payload: { orderHashes: payloadValue },
          signer: this.signer,
          zkPayload: {
            decodedJWT: this.decodedJWT,
            proof: this.proof,
            salt: this.salt,
            maxEpoch: this.maxEpoch,
          },
        });
      } else {
        signature = await this.orderSigner.signPayload({
          orderHashes: payloadValue,
        });
      }

      return `${signature?.signature}${
        signature?.publicAddress
          ? signature?.publicAddress
          : signature?.publicKey
      }`;
    } catch {
      throw Error("Signing cancelled by user");
    }
  };

  /**
   * @description
   * Posts to exchange for cancellation of provided orders with signature
   * @param params OrderCancellationRequest containing order hashes to be cancelled and cancellation signature
   * @returns response from exchange server
   */
  placeCancelOrder = async (params: OrderCancellationRequest) => {
    const response = await this.apiService.delete<CancelOrderResponse>(
      SERVICE_URLS.ORDERS.ORDERS_HASH_V2,
      {
        symbol: params.symbol,
        orderHashes: params.hashes,
        cancelSignature: params.signature,
        parentAddress: params.parentAddress,
        fromUI: true,
      },
      { isAuthenticationRequired: true }
    );
    return response;
  };

  /**
   * @description
   * Creates signature and posts order for cancellation on exchange of provided orders
   * @param params OrderCancelSignatureRequest containing order hashes to be cancelled
   * @returns response from exchange server
   */
  postCancelOrder = async (params: OrderCancelSignatureRequest) => {
    if (params.hashes.length <= 0) {
      throw Error(`No orders to cancel`);
    }
    const signature = await this.createOrderCancellationSignature(params);
    const response = await this.placeCancelOrder({
      ...params,
      signature,
    });
    return response;
  };

  /**
   * @description
   * Cancels all open orders for a given market
   * @param symbol DOT-PERP, market symbol
   * @returns cancellation response
   */
  cancelAllOpenOrders = async (
    symbol: MarketSymbol,
    parentAddress?: string
  ) => {
    const openOrders = await this.getUserOrders({
      symbol,
      statuses: [
        ORDER_STATUS.OPEN,
        ORDER_STATUS.PARTIAL_FILLED,
        ORDER_STATUS.PENDING,
      ],
      parentAddress,
    });

    const hashes = openOrders.data?.map((order) => order.hash) as string[];

    const response = await this.postCancelOrder({
      hashes,
      symbol,
      parentAddress,
    });

    return response;
  };

  /**
   * @description
   * Returns the USDC balance of user in USDC contract
   * @returns list of User's coins in USDC contract
   */
  getUSDCCoins = async (
    amount?: number,
    limit?: number,
    cursor?: string
  ): Promise<any[]> => {
    if (amount) {
      const coin =
        await this.contractCalls.onChainCalls.getUSDCoinHavingBalance({
          amount,
          address:
            this.is_wallet_extension || this.isZkLogin
              ? this.walletAddress
              : this.signer.toSuiAddress(),
          currencyID: this.contractCalls.onChainCalls.getCurrencyID(),
          limit,
          cursor,
        });
      if (coin) {
        coin.balance = usdcToBaseNumber(coin.balance);
      }
      return coin;
    }
    const coins = await this.contractCalls.onChainCalls.getUSDCCoins({
      address: await this.signer.toSuiAddress(),
    });
    coins.data.forEach((coin) => {
      coin.balance = usdcToBaseNumber(coin.balance);
    });

    return coins;
  };

  /**
   * @description
   * Returns the usdc Balance(Free Collateral) of the account in Margin Bank contract
   * @param contract (optional) address of Margin Bank contract
   * @returns Number representing balance of user in Margin Bank contract
   */
  getMarginBankBalance = async (): Promise<number> => {
    return this.contractCalls.getMarginBankBalance();
  };

  /**
   * @description
   * Returns the usdc Balance(Free Collateral) of the account in USDC contract
   * @returns Number representing balance of user in USDC contract
   */
  getUSDCBalance = async (): Promise<number> => {
    return this.contractCalls.onChainCalls.getUSDCBalance(
      {
        address: this.walletAddress,
        currencyID: this.contractCalls.onChainCalls.getCurrencyID(),
      },
      this.signer
    );
  };

  /**
   * @description
   * fetch user sui balance
   * @param walletAddress wallet address of the user
   * @returns string
  
   * */

  getSUIBalance = async (walletAddress?: string): Promise<string> => {
    return this.contractCalls.getSUIBalance(walletAddress);
  };

  /**
   * @description
   * Faucet function, mints 10K USDC to wallet - Only works on Testnet
   * Assumes that the user wallet has native gas Tokens on Testnet
   * @returns Boolean true if user is funded, false otherwise
   */
  mintTestUSDC = async (amount?: number): Promise<boolean> => {
    if (this.network === Networks.PRODUCTION_SUI) {
      throw Error(`Function does not work on PRODUCTION`);
    }
    // mint 10000 USDC
    const mintAmount = amount || 10000;
    const txResponse = await this.contractCalls.onChainCalls.mintUSDC({
      amount: toBigNumberStr(mintAmount, this.MarginTokenPrecision),
      to: await this.signer.toSuiAddress(),
      gasBudget: 1000000000,
    });
    if (Transaction.getStatus(txResponse) === "success") {
      return true;
    }
    return false;
  };

  /**
   * @description
   * Updates user's leverage to given leverage
   * @param symbol market symbol get information about
   * @param leverage new leverage you want to change to
   * @returns ResponseSchema
   */
  adjustLeverage = async (
    params: adjustLeverageRequest
  ): Promise<ResponseSchema> => {
    const userPosition = await this.getUserPosition({
      symbol: params.symbol,
      parentAddress: params.parentAddress,
    });
    if (!userPosition.data) {
      throw Error(`User positions data doesn't exist`);
    }

    const position = userPosition.data as any as GetPositionResponse;

    // Open Position case
    if (Object.keys(position).length > 0) {
      if (params.sponsorTx) {
        // create sponsored adjust leverage call
        let errorMsg = "";
        const sponsorPayload =
          await this.contractCalls.adjustLeverageContractCall(
            params.leverage,
            params.symbol,
            params.parentAddress,
            true
          );
        // only sign the sponsored tx
        const sponsorTxResponse =
          await this.signAndExecuteAdjustLeverageSponsoredTx(
            sponsorPayload,
            false // execute
          );

        errorMsg = sponsorTxResponse?.message;
        if (sponsorTxResponse && sponsorTxResponse.ok) {
          // make dapi call
          // Encode to hex for transmission
          const encodedSignature = combineAndEncode({
            bytes: sponsorTxResponse.data.signedTxb.bytes,
            signature: sponsorTxResponse.data.signedTxb.signature,
          });

          const {
            ok,
            data,
            response: { errorCode, message },
          } = await this.updateLeverage({
            symbol: params.symbol,
            leverage: params.leverage,
            parentAddress: params.parentAddress,
            signedTransaction: encodedSignature,
            sponsorSignature: sponsorTxResponse.data.signedTxb.sponsorSignature,
          });
          const response: ResponseSchema = {
            ok,
            data,
            code: errorCode,
            message,
          };

          // If API is successful return response else make direct contract call to update the leverage
          if (response.ok) {
            return response;
          }

          // fallback to make old sponsored call
          const sponsorTxResponseFallback =
            await this.signAndExecuteSponsoredTx(sponsorPayload);
          if (sponsorTxResponseFallback?.ok) {
            return {
              ok: true,
              code: 200,
              message: "Leverage Updated",
              data: "",
            };
          }
          errorMsg = sponsorTxResponseFallback?.message;
        }

        // recursive call if sponsor fails
        if (errorMsg && errorMsg !== USER_REJECTED_MESSAGE)
          return this.adjustLeverage({ ...params, sponsorTx: false });
        throw new Error(sponsorTxResponse?.message || "Error Adjust Leverage");
      } else {
        // TODO: fix zk login call also via dapi later, leaving for now as we have moved to sponsored calls above
        if (this.isZkLogin) {
          return await this.contractCalls.adjustLeverageContractCall(
            params.leverage,
            params.symbol,
            params.parentAddress
          );
        }

        // sign the transaction only
        const signedTx =
          await this.contractCalls.adjustLeverageContractCallRawTransaction(
            params.leverage,
            params.symbol,
            params.parentAddress
          );

        // execute on dapi
        const {
          ok,
          data,
          response: { errorCode, message },
        } = await this.updateLeverage({
          symbol: params.symbol,
          leverage: params.leverage,
          parentAddress: params.parentAddress,
          signedTransaction: signedTx,
        });
        const response: ResponseSchema = { ok, data, code: errorCode, message };

        // If API is successful return response else make direct contract call to update the leverage
        if (response.ok) {
          return response;
        }

        // fall back for simple adjust leverage call
        return await this.contractCalls.adjustLeverageContractCall(
          params.leverage,
          params.symbol,
          params.parentAddress
        );
      }
    }
    // NO position case
    else {
      const {
        ok,
        data,
        response: { errorCode, message },
      } = await this.updateLeverage({
        symbol: params.symbol,
        leverage: params.leverage,
        parentAddress: params.parentAddress,
      });
      const response: ResponseSchema = { ok, data, code: errorCode, message };
      return response;
    }
  };

  /**
   * @description
   * Whitelist subaccount and/or remove the already exists subaccounts for One Click Trading
   * @param subAccountAddress
   * @param accountsToRemove (optional)
   * @returns ResponseSchema
   */
  upsertSubAccount = async (
    params: SubAccountRequest,
    sponsorTx?: boolean
  ): Promise<ResponseSchema> => {
    const apiResponse = await this.getExpiredAccountsFor1CT();
    const signedTx =
      await this.contractCalls.upsertSubAccountContractCallRawTransaction(
        params.subAccountAddress,
        apiResponse?.data?.expiredSubAccounts ?? [],
        undefined,
        undefined,
        sponsorTx
      );
    if (sponsorTx) {
      const sponsorPayload = signedTx as TransactionBlock;
      const sponsorTxResponse = await this.signAndExecuteSponsoredTx(
        {
          data: sponsorPayload,
          ok: true,
          code: 200,
          message: "",
        },
        false
      );

      if (sponsorTxResponse?.ok) {
        const signedTransaction = combineAndEncode(
          // @ts-ignore
          sponsorTxResponse?.data?.signedTxb
        );

        const request: SignedSubAccountRequest = {
          subAccountAddress: params.subAccountAddress,
          accountsToRemove: params.accountsToRemove,
          signedTransaction,
          sponsorSignature:
            // @ts-ignore
            sponsorTxResponse?.data?.signedTxb?.sponsorSignature,
        };

        const {
          ok,
          data,
          response: { errorCode, message },
        } = await this.addSubAccountFor1CT(request);

        if (ok) {
          const response: ResponseSchema = {
            ok,
            data,
            code: errorCode,
            message,
          };

          return response;
        }
      }

      // recursive call if sponsor fails
      if (
        !sponsorTxResponse?.ok &&
        sponsorTxResponse?.message !== USER_REJECTED_MESSAGE
      ) {
        return this.upsertSubAccount(params, false);
      }
    }

    const request: SignedSubAccountRequest = {
      subAccountAddress: params.subAccountAddress,
      accountsToRemove: params.accountsToRemove,
      signedTransaction: signedTx as string,
    };

    const {
      ok,
      data,
      response: { errorCode, message },
    } = await this.addSubAccountFor1CT(request);

    const response: ResponseSchema = {
      ok,
      data,
      code: errorCode,
      message,
    };

    return response;
  };

  /**
   * @description
   * Add or remove margin from the open position
   * @param symbol market symbol of the open position
   * @param operationType operation you want to perform `Add` | `Remove` margin
   * @param amount (number) amount user wants to add or remove from the position
   * @returns ResponseSchema
   */

  adjustMargin = async (
    symbol: MarketSymbol,
    operationType: ADJUST_MARGIN,
    amount: number,
    sponsorTx?: boolean
  ): Promise<ResponseSchema> => {
    if (sponsorTx) {
      const sponsorPayload = await this.contractCalls.adjustMarginContractCall(
        symbol,
        operationType,
        amount,
        sponsorTx
      );
      if (sponsorPayload.ok) {
        const sponsorTxResponse = await this.signAndExecuteSponsoredTx(
          sponsorPayload
        );
        if (
          !sponsorTxResponse?.ok &&
          sponsorTxResponse?.message !== USER_REJECTED_MESSAGE
        ) {
          return this.adjustMargin(symbol, operationType, amount, false);
        }
        if (!sponsorTxResponse?.ok) {
          throw new Error(
            sponsorTxResponse?.message || "Error adjusting margin"
          );
        }
      }
    }
    return this.contractCalls.adjustMarginContractCall(
      symbol,
      operationType,
      amount,
      sponsorTx
    );
  };

  /**
   * @description
   * Deposits USDC to Margin Bank contract
   * @param amount amount of USDC to deposit
   * @param coinID coinID of USDC coin to use
   * @returns ResponseSchema
   */
  depositToMarginBank = async (
    amount: number,
    coinID?: string,
    sponsorTx?: boolean
  ): Promise<ResponseSchema> => {
    const verifyStatus = await this.verifyWalletStatus(amount);
    if (
      verifyStatus.ok &&
      verifyStatus.data &&
      verifyStatus.data.verificationStatus != "Success"
    ) {
      throwCustomError({
        error: `Deposit Unavailable: Your account is currently ${verifyStatus.data.verificationStatus} from depositing funds`,
      });
    }

    if (sponsorTx) {
      const sponsorTxPayload = await this.depositToMarginBankSponsored(
        amount,
        coinID,
        true
      );
      const sponsorTxResponse = await this.signAndExecuteSponsoredTx(
        sponsorTxPayload
      );
      if ((sponsorTxResponse as ResponseSchema)?.ok) {
        return {
          ok: true,
          code: 200,
          data: sponsorTxResponse,
          message: "Deposit Successful",
        };
      }
      // recursive call if sponsor fails
      if (
        !sponsorTxResponse?.ok &&
        sponsorTxResponse?.message !== USER_REJECTED_MESSAGE
      )
        return this.depositToMarginBank(amount, coinID, false);
    }
    return this.depositToMarginBankSponsored(amount, coinID, false);
  };

  depositToMarginBankSponsored = async (
    amount: number,
    coinID?: string,
    sponsorTx?: boolean
  ) => {
    if (!amount) throwCustomError({ error: "No amount specified for deposit" });

    // if CoinID provided
    if (coinID) {
      const contractCall =
        await this.contractCalls.depositToMarginBankContractCall(
          amount,
          coinID,
          this.getPublicAddress,
          sponsorTx
        );
      if (sponsorTx) {
        await this.signAndExecuteSponsoredTx(contractCall.data);
      } else {
        return contractCall;
      }
    }

    //if no coin id provided

    // Check for a single coin containing enough balance
    const coinHavingBalance = (
      await this.contractCalls.getUSDCHavingBalance(amount)
    )?.coinObjectId;

    if (coinHavingBalance) {
      return await this.contractCalls.depositToMarginBankContractCall(
        amount,
        coinHavingBalance,
        this.getPublicAddress,
        sponsorTx
      );
    }

    // Try merging users' coins if they have more than one coins
    const usdcCoins = await this.contractCalls.getUSDCCoins(this.walletAddress);

    if (usdcCoins.data.length > 1) {
      if (sponsorTx) {
        const sponsorPayload = await this.contractCalls.mergeAllUSDCCOins(
          sponsorTx
        );
        await this.signAndExecuteSponsoredTx({
          ok: true,
          data: sponsorPayload,
          message: "",
        });
      } else {
        await this.contractCalls.mergeAllUSDCCOins(sponsorTx);
      }

      let coinHavingBalanceAfterMerge;
      let retries = 5;

      while (!coinHavingBalanceAfterMerge && retries--) {
        // sleep for 1 second to merge the coins
        await new Promise((resolve) => setTimeout(resolve, 1000));
        coinHavingBalanceAfterMerge = (
          await this.contractCalls.getUSDCHavingBalance(amount)
        )?.coinObjectId;
      }

      if (coinHavingBalanceAfterMerge) {
        return this.contractCalls.depositToMarginBankContractCall(
          amount,
          coinHavingBalanceAfterMerge,
          this.getPublicAddress,
          sponsorTx
        );
      }
    }

    throwCustomError({
      error: `User has no coin with amount ${amount} to deposit`,
    });
  };

  /**
   * @description
   * withdraws USDC from Margin Bank contract
   * @param amount amount of USDC to withdraw
   * @returns ResponseSchema
   */
  withdrawFromMarginBank = async (
    amount?: number,
    sponsorTx?: boolean
  ): Promise<ResponseSchema> => {
    if (sponsorTx) {
      if (amount) {
        try {
          const sponsorTxPayload =
            await this.contractCalls.withdrawFromMarginBankContractCall(
              amount,
              true
            );

          const sponsorTxResponse = await this.signAndExecuteSponsoredTx(
            sponsorTxPayload
          );
          if (sponsorTxResponse?.ok) {
            return {
              ok: true,
              code: 200,
              data: sponsorTxResponse,
              message: "Withdraw Successful",
            };
          }
          // recursive call if sponsor fails and not rejected

          if (
            !sponsorTxResponse?.ok &&
            sponsorTxResponse?.message !== USER_REJECTED_MESSAGE
          ) {
            return this.withdrawFromMarginBank(amount);
          }
          throw new Error(
            sponsorTxResponse?.message || "Error completing withdraw"
          );
        } catch (e) {
          return {
            ok: false,
            code: "Withdraw unsuccessful",
            data: "",
            message: e.message,
          };
        }
      } else {
        return this.contractCalls.withdrawAllFromMarginBankContractCall();
      }
    }
    if (amount) {
      return this.contractCalls.withdrawFromMarginBankContractCall(amount);
    }
    return this.contractCalls.withdrawAllFromMarginBankContractCall();
  };

  /**
   * @description
   * Sets subaccount to wallet.
   * @param publicAddress the address to add as sub account
   * @param status true to add, false to remove
   * @returns ResponseSchema
   */
  setSubAccount = async (
    publicAddress: string,
    status: boolean,
    sponsorTx?: boolean
  ): Promise<ResponseSchema> => {
    if (sponsorTx) {
      const sponsorPayload = await this.contractCalls.setSubAccount(
        publicAddress,
        status,
        true
      );
      if (sponsorPayload?.ok) {
        const sponsorTxResponse = await this.signAndExecuteSponsoredTx(
          sponsorPayload
        );
        return { ok: true, data: sponsorTxResponse, message: "Success" };
      }
    } else {
      return this.contractCalls.setSubAccount(publicAddress, status, true);
    }
  };

  /**
   * @description
   * Gets Users default leverage.
   * @param symbol market symbol get information about
   * @returns user default leverage
   */
  getUserDefaultLeverage = async (
    symbol: MarketSymbol,
    parentAddress?: string
  ) => {
    const accData = await this.getUserAccountData(parentAddress);
    if (!accData.data) {
      throw Error(`Account data does not exist`);
    }

    const accDataByMarket = accData.data.accountDataByMarket.filter((data) => {
      return data.symbol === symbol;
    });
    /// found accountDataByMarket
    if (accDataByMarket && accDataByMarket.length > 0) {
      return toBaseNumber(accDataByMarket[0].selectedLeverage);
    }
    /// user is new and symbol data is not present in accountDataByMarket
    const exchangeInfo = await this.getExchangeInfo(symbol);
    if (!exchangeInfo.data) {
      throw Error(`Provided Market Symbol(${symbol}) does not exist`);
    }
    return toBaseNumber(exchangeInfo.data.defaultLeverage);
  };

  /**
   * @description
   * Gets Orders placed by the user. Returns the first 50 orders by default.
   * @param params of type OrderRequest,
   * @returns OrderResponse array
   */
  getUserOrders = async (params: GetOrderRequest) => {
    const response = await this.apiService.get<GetOrderResponse[]>(
      SERVICE_URLS.USER.ORDERS,
      {
        ...params,
      },
      { isAuthenticationRequired: true }
    );
    return response;
  };

  /**
   * @description
   * Gets user open position. If the market is not specified then will return first 50 open positions for 50 markets.
   * @param params GetPositionRequest
   * @returns GetPositionResponse
   */
  getUserPosition = async (params: GetPositionRequest) => {
    const response = await this.apiService.get<GetPositionResponse[]>(
      SERVICE_URLS.USER.USER_POSITIONS,
      { ...params },
      { isAuthenticationRequired: true }
    );
    return response;
  };

  /**
   * @description
   * Gets state of orderbook for provided market. At max top 50 bids/asks are retrievable
   * @param params GetOrderbookRequest
   * @returns GetOrderbookResponse
   */
  getOrderbook = async (params: GetOrderbookRequest) => {
    const response = await this.apiService.get<GetOrderBookResponse>(
      SERVICE_URLS.MARKET.ORDER_BOOK,
      params
    );

    return response;
  };

  /**
   * @description
   * Gets user trades
   * @param params GetUserTradesRequest
   * @returns GetUserTradesResponse
   */
  getUserTrades = async (params: GetUserTradesRequest) => {
    const response = await this.apiService.get<GetUserTradesResponse>(
      SERVICE_URLS.USER.USER_TRADES,
      { ...params },
      { isAuthenticationRequired: true }
    );

    return response;
  };

  /**
   * Gets user trades history
   * @param params GetUserTradesHistoryRequest
   * @returns GetUserTradesHistoryResponse
   */
  getUserTradesHistory = async (params: GetUserTradesHistoryRequest) => {
    const response = await this.apiService.get<GetUserTradesHistoryResponse>(
      SERVICE_URLS.USER.USER_TRADES_HISTORY,
      { ...params },
      { isAuthenticationRequired: true }
    );

    return response;
  };

  /**
   * @description
   * Gets user Account Data
   * @returns GetAccountDataResponse
   */
  getUserAccountData = async (parentAddress?: string) => {
    const response = await this.apiService.get<GetAccountDataResponse>(
      SERVICE_URLS.USER.ACCOUNT,
      { parentAddress },
      { isAuthenticationRequired: true }
    );
    return response;
  };

  /**
   * @description
   * Gets verification status of user account
   * @param amount deposit amount
   * @returns verification status of user
   */
  verifyWalletStatus = async (amount: number) => {
    const response = await this.apiService.get<VerifyWalletStatusResponse>(
      SERVICE_URLS.USER.VERIFY_WALLET_STATUS,
      { depositAmount: amount },
      { isAuthenticationRequired: true }
    );

    return response;
  };

  /**
   * @description
   * Gets user transaction history
   * @param params GetTransactionHistoryRequest
   * @returns GetUserTransactionHistoryResponse
   */
  getUserTransactionHistory = async (params: GetTransactionHistoryRequest) => {
    const response = await this.apiService.get<
      GetUserTransactionHistoryResponse[]
    >(
      SERVICE_URLS.USER.USER_TRANSACTION_HISTORY,
      {
        ...params,
      },
      { isAuthenticationRequired: true }
    );
    return response;
  };

  /**
   * @description
   * Gets user funding history
   * @param params GetFundingHistoryRequest
   * @returns GetUserTransactionHistoryResponse
   */
  getUserFundingHistory = async (params: GetFundingHistoryRequest) => {
    const response = await this.apiService.get<GetUserFundingHistoryResponse>(
      SERVICE_URLS.USER.FUNDING_HISTORY,
      {
        ...params,
      },
      { isAuthenticationRequired: true }
    );
    return response;
  };

  /**
   * @description
   * Gets user transfer history
   * @param params GetTransferHistoryRequest
   * @returns GetUserTransferHistoryResponse
   */
  getUserTransferHistory = async (params: GetTransferHistoryRequest) => {
    const response = await this.apiService.get<GetUserTransferHistoryResponse>(
      SERVICE_URLS.USER.TRANSFER_HISTORY,
      {
        ...params,
      },
      { isAuthenticationRequired: true }
    );
    return response;
  };

  /**
   * @description
   * Gets market funding rate
   * @param symbol market symbol to fetch funding rate of
   * @returns GetFundingRateResponse
   */
  getMarketFundingRate = async (symbol: MarketSymbol) => {
    const response = await this.apiService.get<GetFundingRateResponse>(
      SERVICE_URLS.MARKET.FUNDING_RATE,
      {
        symbol,
      }
    );
    return response;
  };

  /**
   * @description
   * Gets market recent trades
   * @param params GetMarketRecentTradesRequest
   * @returns GetMarketRecentTradesResponse
   */
  getMarketRecentTrades = async (params: GetMarketRecentTradesRequest) => {
    const response = await this.apiService.get<GetMarketRecentTradesResponse>(
      SERVICE_URLS.MARKET.RECENT_TRADE,
      params
    );
    return response;
  };

  /**
   * @description
   * Gets market candle stick data
   * @param params GetMarketRecentTradesRequest
   * @returns DAPIKlineResponse
   */
  getMarketCandleStickData = async (params: GetCandleStickRequest) => {
    const response = await this.apiService.get<DAPIKlineResponse>(
      SERVICE_URLS.MARKET.CANDLE_STICK_DATA,
      params
    );
    return response;
  };

  /**
   * @description
   * Gets publicly available market info about market(s)
   * @param symbol (optional) market symbol get information about, by default fetches info on all available markets
   * @returns ExchangeInfo or ExchangeInfo[] in case no market was provided as input
   */
  getExchangeInfo = async (symbol?: MarketSymbol) => {
    const response = await this.apiService.get<ExchangeInfo>(
      SERVICE_URLS.MARKET.EXCHANGE_INFO,
      { symbol }
    );
    return response;
  };

  /**
   * @description
   * Gets MarketData data for market(s)
   * @param symbol (optional) market symbol get information about, by default fetches info on all available markets
   * @returns MarketData or MarketData[] in case no market was provided as input
   */
  getMarketData = async (symbol?: MarketSymbol) => {
    const response = await this.apiService.get<MarketData>(
      SERVICE_URLS.MARKET.MARKET_DATA,
      { symbol }
    );
    return response;
  };

  /**
   * @description
   * Gets Meta data of the market(s)
   * @param symbol (optional) market symbol get information about, by default fetches info on all available markets
   * @returns MarketMeta or MarketMeta[] in case no market was provided as input
   */
  getMarketMetaInfo = async (symbol?: MarketSymbol) => {
    const response = await this.apiService.get<MarketMeta>(
      SERVICE_URLS.MARKET.META,
      { symbol }
    );
    return response;
  };

  /**
   * @description
   * Gets Master Info of the market(s)
   * @param symbol (optional) market symbol get information about, by default fetches info on all available markets
   * @returns MasterInfo
   */
  getMasterInfo = async (symbol?: MarketSymbol) => {
    const response = await this.apiService.get<MasterInfo>(
      SERVICE_URLS.MARKET.MASTER_INFO,
      { symbol }
    );
    return response;
  };

  /**
   * @description
   * Gets the list of market symbols available on exchange
   * @returns array of strings representing MARKET SYMBOLS
   */
  getMarketSymbols = async () => {
    const response = await this.apiService.get<string[]>(
      SERVICE_URLS.MARKET.SYMBOLS
    );
    return response;
  };

  /**
   * @description
   * Gets contract addresses of market
   * @param symbol (optional) market symbol get information about, by default fetches info on all available markets
   * @returns deployed contract addresses
   */
  getContractAddresses = async (symbol?: MarketSymbol) => {
    const response = await this.apiService.get<Record<string, object>>(
      SERVICE_URLS.MARKET.CONTRACT_ADDRESSES,
      { symbol }
    );
    return response;
  };

  /**
   * @description
   * Gets status of the exchange
   * @returns StatusResponse
   */
  getExchangeStatus = async () => {
    const response = await this.apiService.get<StatusResponse>(
      SERVICE_URLS.MARKET.STATUS
    );
    return response;
  };

  /**
   * @description
   * Gets ticker data of any market
   * @param symbol market symbol to get information about, if not provided fetches data of all markets
   * @returns TickerData
   */
  getTickerData = async (symbol?: MarketSymbol) => {
    const response = await this.apiService.get<TickerData>(
      SERVICE_URLS.MARKET.TICKER,
      { symbol }
    );
    return response;
  };

  /**
   * Generates referral code
   * @param params GenerateReferralCodeRequest
   * @returns GenerateReferralCodeResponse
   */
  generateReferralCode = async (params: GenerateReferralCodeRequest) => {
    const response = await this.apiService.post<GenerateReferralCodeResponse>(
      SERVICE_URLS.GROWTH.GENERATE_CODE,
      params,
      { isAuthenticationRequired: true }
    );
    return response;
  };

  /**
   * Links referred user
   * @param params LinkReferredUserRequest
   * @returns LinkReferredUserResponse
   */
  affiliateLinkReferredUser = async (params: LinkReferredUserRequest) => {
    const response = await this.apiService.post<LinkReferredUserResponse>(
      SERVICE_URLS.GROWTH.AFFILIATE_LINK_REFERRED_USER,
      params,
      { isAuthenticationRequired: true }
    );
    return response;
  };

  /**
   * Gets referrer Info
   * @param parentAddress
   * @returns GetReferrerInfoResponse
   */

  getReferrerInfo = async (parentAddress?: string) => {
    const response = await this.apiService.get<GetReferrerInfoResponse>(
      SERVICE_URLS.GROWTH.REFERRER_INFO,
      { parentAddress },
      { isAuthenticationRequired: true }
    );
    return response;
  };

  /**
   * Gets campaign details
   * @returns Array of GetCampaignDetailsResponse
   */
  getCampaignDetails = async () => {
    const response = await this.apiService.get<GetCampaignDetailsResponse[]>(
      SERVICE_URLS.GROWTH.CAMPAIGN_DETAILS
    );
    return response;
  };

  /**
   * Gets campaign reward details
   * @param campaignId
   * @param parentAddress
   * @returns GetCampaignRewardsResponse
   */
  getCampaignRewards = async (campaignId: number, parentAddress?: string) => {
    const response = await this.apiService.get<GetCampaignRewardsResponse>(
      SERVICE_URLS.GROWTH.CAMPAIGN_REWARDS,
      { campaignId, parentAddress },
      { isAuthenticationRequired: true }
    );
    return response;
  };

  /**
   * Gets affiliate payout details
   * @param campaignId
   * @param parentAddress
   * @returns Array of GetAffiliatePayoutsResponse
   */
  getAffiliatePayouts = async (campaignId: number, parentAddress?: string) => {
    const response = await this.apiService.get<GetAffiliatePayoutsResponse[]>(
      SERVICE_URLS.GROWTH.AFFILIATE_PAYOUTS,
      { campaignId, parentAddress },
      { isAuthenticationRequired: true }
    );
    return response;
  };

  /**
   * Gets affiliate referree details
   * @param GetAffiliateRefereeDetailsRequest
   * @returns GetAffiliateRefereeDetailsResponse
   */
  getAffiliateRefereeDetails = async (
    params: GetAffiliateRefereeDetailsRequest
  ) => {
    const response =
      await this.apiService.get<GetAffiliateRefereeDetailsResponse>(
        SERVICE_URLS.GROWTH.AFFILIATE_REFEREE_DETAILS,
        params,
        { isAuthenticationRequired: true }
      );
    return response;
  };

  /**
   * Gets referree count
   * @param campaignId
   * @param parentAddress
   * @returns GetAffiliateRefereeCountResponse
   */
  getAffiliateRefereeCount = async (
    campaignId: number,
    parentAddress?: string
  ) => {
    const response =
      await this.apiService.get<GetAffiliateRefereeCountResponse>(
        SERVICE_URLS.GROWTH.AFFILIATE_REFEREES_COUNT,
        { campaignId, parentAddress },
        { isAuthenticationRequired: true }
      );
    return response;
  };

  /**
   * Gets user rewards history
   * @param optional params GetUserRewardsHistoryRequest
   * @returns GetUserRewardsHistoryResponse
   */
  getUserRewardsHistory = async (params?: GetUserRewardsHistoryRequest) => {
    const response = await this.apiService.get<GetUserRewardsHistoryResponse>(
      SERVICE_URLS.GROWTH.USER_REWARDS_HISTORY,
      params,
      { isAuthenticationRequired: true }
    );
    return response;
  };

  /**
   * Gets user rewards summary
   * @returns GetUserRewardsSummaryResponse
   */
  getUserRewardsSummary = async (parentAddress?: string) => {
    const response = await this.apiService.get<GetUserRewardsSummaryResponse>(
      SERVICE_URLS.GROWTH.USER_REWARDS_SUMMARY,
      { parentAddress },
      { isAuthenticationRequired: true }
    );
    return response;
  };

  /**
   * Gets rewards overview
   * @param campaignId
   * @param parentAddress
   * @returns GetTradeAndEarnRewardsOverviewResponse
   */
  getTradeAndEarnRewardsOverview = async (
    campaignId: number,
    parentAddress?: string
  ) => {
    const response =
      await this.apiService.get<GetTradeAndEarnRewardsOverviewResponse>(
        SERVICE_URLS.GROWTH.REWARDS_OVERVIEW,
        { campaignId, parentAddress },
        { isAuthenticationRequired: true }
      );
    return response;
  };

  /**
   * Gets rewards details
   * @param GetTradeAndEarnRewardsDetailRequest
   * @returns GetTradeAndEarnRewardsDetailResponse
   */
  getTradeAndEarnRewardsDetail = async (
    params: GetTradeAndEarnRewardsDetailRequest
  ) => {
    const response =
      await this.apiService.get<GetTradeAndEarnRewardsDetailResponse>(
        SERVICE_URLS.GROWTH.REWARDS_DETAILS,
        params,
        { isAuthenticationRequired: true }
      );
    return response;
  };

  /**
   * Gets total historical trading reward details
   * @returns GetTotalHistoricalTradingRewardsResponse
   */
  getTotalHistoricalTradingRewards = async (parentAddress?: string) => {
    const response =
      await this.apiService.get<GetTotalHistoricalTradingRewardsResponse>(
        SERVICE_URLS.GROWTH.TOTAL_HISTORICAL_TRADING_REWARDS,
        { parentAddress },
        { isAuthenticationRequired: true }
      );
    return response;
  };

  /**
   * Gets maker rewards summary
   * @returns GetMakerRewardsSummaryResponse
   */
  getMakerRewardsSummary = async (parentAddress?: string) => {
    const response = await this.apiService.get<GetMakerRewardsSummaryResponse>(
      SERVICE_URLS.GROWTH.MAKER_REWARDS_SUMMARY,
      { parentAddress },
      { isAuthenticationRequired: true }
    );
    return response;
  };

  /**
   * Gets maker reward details
   * @param GetMakerRewardDetailsRequest
   * @returns GetMakerRewardDetailsResponse
   */
  getMakerRewardDetails = async (params: GetMakerRewardDetailsRequest) => {
    const response = await this.apiService.get<GetMakerRewardDetailsResponse>(
      SERVICE_URLS.GROWTH.MAKER_REWARDS_DETAILS,
      params,
      { isAuthenticationRequired: true }
    );
    return response;
  };

  /**
   * Gets market maker whitelist status
   * @returns GetUserWhiteListStatusForMarketMaker
   */
  getUserWhiteListStatusForMarketMaker = async () => {
    const response =
      await this.apiService.get<GetUserWhiteListStatusForMarketMakerResponse>(
        SERVICE_URLS.GROWTH.MAKER_WHITELIST_STATUS,
        {},
        { isAuthenticationRequired: true }
      );
    return response;
  };

  // Open referral Program
  /**
   * get open referral referee details
   * @param payload
   * @returns OpenReferralRefereeDetails
   */
  getOpenReferralRefereeDetails = async (payload: {
    cursor: string;
    pageSize: number;
    parentAddress?: string;
  }) => {
    const response = await this.apiService.get<{
      data: OpenReferralRefereeDetails;
      nextCursor: string;
      isMoreDataAvailable: boolean;
      parentAddress?: string;
    }>(SERVICE_URLS.GROWTH.OPEN_REFERRAL_REFEREE_DETAILS, payload, {
      isAuthenticationRequired: true,
    });
    return response;
  };

  /**
   * get open referral payouts
   * @param payload
   * @returns OpenReferralDetails
   */
  getOpenReferralDetails = async (payload: {
    campaignId: number;
    parentAddress?: string;
  }) => {
    const response = await this.apiService.get<OpenReferralDetails>(
      SERVICE_URLS.GROWTH.OPEN_REFERRAL_REFEREES_COUNT,
      payload,
      { isAuthenticationRequired: true }
    );
    return response;
  };

  /**
   * get open referral payouts
   * @param payload
   * @returns OpenReferralPayoutList
   */
  getOpenReferralPayouts = async (payload: {
    cursor: string;
    pageSize: number;
    parentAddress?: string;
  }) => {
    const response = await this.apiService.get<{
      data: OpenReferralPayoutList;
      nextCursor: string;
      isMoreDataAvailable: boolean;
    }>(SERVICE_URLS.GROWTH.OPEN_REFERRAL_PAYOUTS, payload, {
      isAuthenticationRequired: true,
    });
    return response;
  };

  /**
   * generate open referral code
   * @param campaignId
   * @param parentAddress
   * @returns OpenReferralOverview
   */
  generateOpenReferralReferralCode = async (payload: {
    campaignId: string;
  }) => {
    const response = await this.apiService.post<{
      referralAddress: string;
      referralCode: string;
      message: string;
    }>(SERVICE_URLS.GROWTH.OPEN_REFERRAL_GENERATE_CODE, payload, {
      isAuthenticationRequired: true,
    });
    return response;
  };

  /**
   * get open referral overview
   * @returns OpenReferralOverview
   */
  getOpenReferralOverview = async (parentAddress?: string) => {
    const response = await this.apiService.get<OpenReferralOverview>(
      SERVICE_URLS.GROWTH.OPEN_REFERRAL_OVERVIEW,
      { parentAddress },
      {
        isAuthenticationRequired: true,
      }
    );
    return response;
  };

  /**
   * Link open referral
   * @param referralCode
   * @returns boolean
   */

  openReferralLinkReferredUser = async (payload: { referralCode: string }) => {
    const response = await this.apiService.post(
      SERVICE_URLS.GROWTH.OPEN_REFERRAL_LINK_REFERRED_USER,
      payload,
      {
        isAuthenticationRequired: true,
      }
    );
    return response;
  };

  // Open referral Program

  //= ==============================================================//
  //                    PRIVATE HELPER FUNCTIONS
  //= ==============================================================//

  /**
   * @description
   * Initializes order signer
   * @param keypair keypair of the account to be used for placing orders
   * @returns void
   */
  private initOrderSigner = (keypair: Signer) => {
    this.orderSigner = new OrderSigner(keypair);
  };

  /**
   * @description
   * Gets deployment json from local file (will get from DAPI in future)
   * @returns deployment json
   * */
  private getDeploymentJson = async (): Promise<any> => {
    try {
      // Fetch data from the given URL
      const response = await this.apiService.get<ConfigResponse>(
        SERVICE_URLS.MARKET.CONFIG
      );
      // The data property of the response object contains our configuration
      return response.data.deployment;
    } catch (error) {
      // If Axios threw an error, it will be stored in error.response
      if (error.response) {
        throw new Error(`Failed to fetch deployment: ${error.response.status}`);
      } else {
        throw new Error(`An error occurred: ${error}`);
      }
    }
  };

  /**
   * @description
   * sign transaction using wallet
   * @param tx transcation block
   * @param signer signer object
   * @returns transactionBlockBytes & signature
   * */
  private signTransactionUsingWallet = async (
    tx: TransactionBlock,
    signer: ExtendedWalletContextState
  ) => {
    try {
      return signer.signTransactionBlock({
        transactionBlock: tx,
      });
    } catch (error) {
      throwCustomError({
        error,
        code: Errors.WALLET_TRANSACTION_SIGNING_FAILED,
      });
    }
  };

  /**
   * @description
   * sign transcation using ZK
   * @param tx transcation block
   * @returns SignatureWithBytes
   * */

  private signTransactionUsingZK = async (tx: TransactionBlock) => {
    try {
      return await tx.sign({
        client: this.provider,
        signer: this.signer as Keypair,
      });
    } catch (error) {
      throwCustomError({
        error,
        code: Errors.ZK_TRANSACTION_SIGNING_FAILED,
      });
    }
  };

  /**
   * @description
   * sign transcation using keypair
   * @param txBytes transaction bytes
   * @returns SignatureWithBytes
   * */

  private signTransactionUsingKeypair = async (txBytes: Uint8Array) => {
    try {
      return await this.signer.signTransaction(txBytes);
    } catch (error) {
      throwCustomError({
        error,
        code: Errors.KEYPAIR_TRANSACTION_SIGNING_FAILED,
      });
    }
  };

  /**
   * @description
   * execute sponsored transaction block
   * @param blockTxBytes transaction bytes
   * @param signature signature
   * @param sponsorerSignature sponserer signature
   * @returns SuiTransactionBlockResponse
   * */

  private executeSponseredTransactionBlock = async (
    blockTxBytes: string,
    signature: string,
    sponsorerSignature: string
  ) => {
    try {
      return await SuiBlocks.executeSponsoredTxBlock(
        blockTxBytes,
        signature,
        sponsorerSignature,
        this.provider
      );
    } catch (error) {
      throwCustomError({
        error,
        code: Errors.EXECUTE_SPONSORED_TRANSACTION_FAILED,
      });
    }
  };

  /**
   * @description
   * build gasless transaction payload bytes
   * @param tx transcation block
   * @returns string
   * */

  private buildGaslessTxPayloadBytes = async (txb: TransactionBlock) => {
    try {
      return await SuiBlocks.buildGaslessTxPayloadBytes(txb, this.provider);
    } catch (error) {
      throwCustomError({
        error,
        code: Errors.BUILD_GASLESS_PAYLOAD_TX_PAYLOAD_BYTES_FAILED,
      });
    }
  };

  /**
   * @description
   * prompts user to sign the transaction and executes
   *  @param sponsorPayload payload from library-sui
   * @returns completed transaction
   * */
  private signAndExecuteSponsoredTx = async (
    sponsorPayload: ResponseSchema,
    execute: boolean = true
  ) => {
    const bytes = await this.buildGaslessTxPayloadBytes(sponsorPayload.data);

    const sponsorTxResponse = await this.getSponsoredTxResponse(bytes);

    const { data, ok } = sponsorTxResponse;

    if (ok && data?.data && data?.data?.txBytes) {
      const txBytes = fromBase64(data.data.txBytes);
      const txBlock = TransactionBlock.from(txBytes);

      if (this.uiWallet) {
        const signedTxb = await this.signTransactionUsingWallet(
          txBlock,
          this.signer as unknown as ExtendedWalletContextState
        );

        const { transactionBlockBytes, signature } = signedTxb;

        if (execute) {
          const executedResponse = await this.executeSponseredTransactionBlock(
            transactionBlockBytes,
            signature,
            data.data.signature
          );
          return {
            code: "Success",
            ok: true,
            data: {
              ...executedResponse,
              signedTxb: {
                ...signedTxb,
                sponsorSignature: data.data.signature,
                bytes: signedTxb?.transactionBlockBytes,
              },
            },
          };
        }
        return {
          code: "Success",
          ok: true,
          data: {
            signedTxb: {
              ...signedTxb,
              sponsorSignature: data.data.signature,
              bytes: signedTxb?.transactionBlockBytes,
            },
          },
        };
      }
      if (this.isZkLogin) {
        const signedTxb = await this.signTransactionUsingZK(txBlock);

        const { bytes, signature: userSignature } = signedTxb;

        const zkSignature = createZkSignature({
          userSignature,
          zkPayload: this.getZkPayload(),
        });

        if (execute) {
          const executedResponse = await this.executeSponseredTransactionBlock(
            bytes,
            zkSignature,
            data.data.signature
          );
          return {
            code: "Success",
            ok: true,
            data: {
              ...executedResponse,
              signedTxb: {
                sponsorSignature: data.data.signature,
              },
            },
          };
        }
        return {
          code: "Success",
          ok: true,
          data: {
            signedTxb: {
              ...signedTxb,
              sponsorSignature: data.data.signature,
              bytes: signedTxb?.bytes,
            },
          },
        };
      } else {
        const { signature, bytes } = await this.signTransactionUsingKeypair(
          txBytes
        );
        const executedResponse = await this.executeSponseredTransactionBlock(
          bytes,
          signature,
          data.data.signature
        );
        return {
          code: "Success",
          ok: true,
          data: {
            ...executedResponse,
            signedTxb: {
              sponsorSignature: data.data.signature,
            },
          },
        };
      }
    } else {
      return {
        ok: false,
        message: "Something Went Wrong",
        data: "",
        code: 400,
      };
    }
  };

  private signAndExecuteAdjustLeverageSponsoredTx = async (
    sponsorPayload: ResponseSchema,
    execute: boolean = true
  ): Promise<{
    code: string;
    ok: boolean;
    message: string;
    data: {
      sponsoredExecutedCallResponse?: SuiTransactionBlockResponse;
      signedTxb: {
        bytes: string;
        signature: string;
        sponsorSignature: string;
      };
    };
  }> => {
    const bytes = await SuiBlocks.buildGaslessTxPayloadBytes(
      sponsorPayload.data,
      this.provider
    );

    const sponsorTxResponse = await this.getSponsoredTxResponse(bytes);

    const { data, ok } = sponsorTxResponse;
    try {
      if (ok && data && data.data) {
        // dapi returning ok even when there's error
        const txBytes = fromBase64(data.data.txBytes);
        const txBlock = TransactionBlock.from(txBytes);

        if (this.uiWallet) {
          const signedTxb = await (
            this.signer as unknown as ExtendedWalletContextState
          ).signTransactionBlock({
            transactionBlock: txBlock,
          });
          const { transactionBlockBytes, signature } = signedTxb;
          if (execute) {
            const executedResponse = await SuiBlocks.executeSponsoredTxBlock(
              transactionBlockBytes,
              signature,
              data.data.signature,
              this.provider
            );
            return {
              code: "Success",
              ok: true,
              message: "",
              data: {
                sponsoredExecutedCallResponse: { ...executedResponse },
                signedTxb: {
                  bytes: signedTxb?.transactionBlockBytes,
                  signature: signedTxb?.signature,
                  sponsorSignature: data.data.signature,
                },
              },
            };
          }
          return {
            code: "Success",
            ok: true,
            message: "",
            data: {
              signedTxb: {
                bytes: signedTxb?.transactionBlockBytes,
                signature: signedTxb?.signature,
                sponsorSignature: data.data.signature,
              },
            },
          };
        }

        if (this.isZkLogin) {
          const tx = TransactionBlock.from(txBytes);

          const signedTxb = await tx.sign({
            client: this.provider,
            signer: this.signer as Keypair,
          });

          const { bytes, signature: userSignature } = signedTxb;

          const zkSignature = createZkSignature({
            userSignature,
            zkPayload: this.getZkPayload(),
          });

          if (execute) {
            const executedResponse = await SuiBlocks.executeSponsoredTxBlock(
              bytes,
              zkSignature,
              data.data.signature,
              this.provider
            );
            return {
              code: "Success",
              ok: true,
              message: "",
              data: {
                sponsoredExecutedCallResponse: { ...executedResponse },
                signedTxb: {
                  sponsorSignature: data.data.signature,
                  bytes,
                  signature: zkSignature,
                },
              },
            };
          }

          return {
            code: "Success",
            ok: true,
            message: "",
            data: {
              signedTxb: {
                sponsorSignature: data.data.signature,
                bytes,
                signature: zkSignature,
              },
            },
          };
        }

        // any other case
        const signedTxb = await this.signer.signTransaction(txBytes);
        if (execute) {
          const { signature, bytes } = signedTxb;
          const executedResponse = await SuiBlocks.executeSponsoredTxBlock(
            bytes,
            signature,
            data.data.signature,
            this.provider
          );
          return {
            code: "Success",
            ok: true,
            message: "",
            data: {
              sponsoredExecutedCallResponse: { ...executedResponse },
              signedTxb: {
                sponsorSignature: data.data.signature,
                bytes: signedTxb?.bytes,
                signature: signedTxb?.signature,
              },
            },
          };
        }

        return {
          code: "Success",
          ok: true,
          message: "",
          data: {
            signedTxb: {
              bytes: signedTxb?.bytes,
              signature: signedTxb?.signature,
              sponsorSignature: data.data.signature,
            },
          },
        };
      }
      // @ts-ignore
      throw new Error(sponsorTxResponse.data?.error?.message);
    } catch (e) {
      return {
        code: "Failed",
        ok: false,
        message: e.message || "Something Went Wrong",
        data: {
          signedTxb: {
            signature: "",
            bytes: "",
            sponsorSignature: "",
          },
        },
      };
    }
  };

  /**
   * Function to create order payload that is to be signed on-chain
   * @param params OrderSignatureRequest
   * @returns Order
   */
  public createOrderToSign = (
    params: OrderSignatureRequest,
    parentAddress?: string
  ): Order => {
    const expiration = new Date();
    // MARKET ORDER - set expiration of 1 minute
    if (params.orderType === ORDER_TYPE.MARKET) {
      expiration.setMinutes(expiration.getMinutes() + 1);
    }
    // LIMIT ORDER - set expiration of 1 month
    else {
      expiration.setMonth(expiration.getMonth() + 1);
    }
    const salt =
      params.salt && params.salt < this.maxSaltLimit
        ? bigNumber(params.salt)
        : bigNumber(generateRandomNumber(1_000));
    return {
      market: this.contractCalls.onChainCalls.getPerpetualID(params.symbol),
      price: toBigNumber(params.price),
      isBuy: params.side === ORDER_SIDE.BUY,
      quantity: toBigNumber(params.quantity),
      leverage: toBigNumber(params.leverage || 1),
      maker: parentAddress || this.getPublicAddress().toLocaleLowerCase(),
      reduceOnly: params.reduceOnly == true,
      expiration: bigNumber(
        params.expiration || Math.floor(expiration.getTime())
      ), // /1000 to convert time in seconds
      postOnly: params.postOnly == true,
      cancelOnRevert: params.cancelOnRevert == true,
      salt,
      orderbookOnly: params.orderbookOnly || true,
      ioc: params.timeInForce === TIME_IN_FORCE.IMMEDIATE_OR_CANCEL || false,
    };
  };

  /**
   * @description
   * Posts signed Auth Hash to dAPI and gets token in return if signature is valid
   * @returns GetAuthHashResponse which contains auth hash to be signed
   */
  private authorizeSignedHash = async (signedHash: string) => {
    try {
      const response = await this.apiService.post<AuthorizeHashResponse>(
        SERVICE_URLS.USER.AUTHORIZE,
        {
          signature: signedHash,
          userAddress: this.getPublicAddress(),
          isTermAccepted: this.isTermAccepted,
        }
      );
      return response;
    } catch (error) {
      throwCustomError({ error, code: Errors.DAPI_ERROR });
    }
  };

  /**
   * @description
   * Posts signed Auth Hash to dAPI and gets token in return if signature is valid
   * @returns GetAuthHashResponse which contains auth hash to be signed
   */
  private updateLeverage = async (params: adjustLeverageRequest) => {
    const response = await this.apiService.post<AdjustLeverageResponse>(
      SERVICE_URLS.USER.ADJUST_LEVERAGE,
      {
        symbol: params.symbol,
        address: params.parentAddress || this.getPublicAddress(),
        leverage: toBigNumberStr(params.leverage),
        marginType: MARGIN_TYPE.ISOLATED,
        signedTransaction: params.signedTransaction,
        sponsorSignature: params.sponsorSignature,
      },
      { isAuthenticationRequired: true }
    );
    return response;
  };

  /**
   * @description
   * Posts subAccount request to whitelist/remove the subaccount for One Click Trading
   * @returns SubAccountResponse containing whitelisted subaccount details
   */
  private addSubAccountFor1CT = async (params: SignedSubAccountRequest) => {
    try {
      const response = await this.apiService.post<SubAccountResponse>(
        SERVICE_URLS.USER.SUBACCOUNT_1CT,
        params,
        { isAuthenticationRequired: true }
      );
      return response;
    } catch (error) {
      throwCustomError({ error, code: Errors.DAPI_ERROR });
    }
  };

  /**
   * @description
   * Get expired 1CT subAccount list for user that are still active
   * @returns ExpiredSubAccounts1CTResponse
   */
  private getExpiredAccountsFor1CT = async () => {
    try {
      const response = await this.apiService.get<Expired1CTSubAccountsResponse>(
        SERVICE_URLS.USER.EXPIRED_SUBACCOUNT_1CT,
        null,
        { isAuthenticationRequired: true }
      );
      return response;
    } catch (error) {
      throwCustomError({ error, code: Errors.DAPI_ERROR });
    }
  };

  /**
   * @description
   * Get transcation response for sponsored payload
   * @returns SponsorTxResponse
   */
  getSponsoredTxResponse = async (txBytes) => {
    try {
      const response = await this.apiService.post<SponsorTxResponse>(
        SERVICE_URLS.USER.SPONSOR_TX,
        { txBytes },
        { isAuthenticationRequired: true }
      );
      return response;
    } catch (error) {
      throwCustomError({ error, code: Errors.DAPI_ERROR });
    }
  };

  /**
   * @description
   * Get transcation response for sponsored payload
   * @returns SponsorTxResponse
   */
  getOffchainSettlementUpdates = async (
    params: GetOffchainSettlementUpdatesRequest
  ) => {
    try {
      const response =
        await this.apiService.get<GetOffchainSettlementUpdatesResponse>(
          SERVICE_URLS.USER.OFFCHAIN_SETTLEMENT_UPDATES,
          { ...params },
          { isAuthenticationRequired: true }
        );
      return response;
    } catch (error) {
      throwCustomError({ error, code: Errors.DAPI_ERROR });
    }
  };

  /**
   * @description
   * Reset timer for cancel on disconnect for open orders
   * @param params PostTimerAttributes containing the countdowns of all markets
   * @returns PostTimerResponse containing accepted and failed countdowns. If status is not 201, request wasn't successful.
   */
  resetCancelOnDisconnectTimer = async (params: PostTimerAttributes) => {
    const response = await this.apiService.post<PostTimerResponse>(
      SERVICE_URLS.USER.CANCEL_ON_DISCONNECT,
      params,
      { isAuthenticationRequired: true },
      this.network.dmsURL
    );
    if (response.status === 503) {
      throw Error(
        `Cancel on Disconnect (dead-mans-switch) feature is currently unavailable`
      );
    }
    return response;
  };

  /**
   * @description
   * Gets user Cancel on Disconnect timer
   * @returns GetCountDownsResponse
   */
  getCancelOnDisconnectTimer = async (
    symbol?: string,
    parentAddress?: string
  ) => {
    const response = await this.apiService.get<GetCountDownsResponse>(
      SERVICE_URLS.USER.CANCEL_ON_DISCONNECT,
      {
        parentAddress,
        symbol,
      },
      { isAuthenticationRequired: true },
      this.network.dmsURL
    );
    if (response.status === 503) {
      throw Error(
        `Cancel on Disconnect (dead-mans-switch) feature is currently unavailable`
      );
    }
    return response;
  };

  signAndExecuteZkTransaction = async (tx: TransactionBlock) => {
    try {
      if (!this.signer || !this.walletAddress)
        throw new Error("invalid signer or wallet address");
      if (isEmpty(this.getZkPayload())) throw new Error("invalid zk payloads");

      tx.setSender(this.walletAddress);
      const { bytes, signature: userSignature } = await tx.sign({
        client: this.provider,
        signer: this.signer as Keypair,
      });
      const zkSignature = createZkSignature({
        userSignature,
        zkPayload: this.getZkPayload(),
      });
      return this.provider.executeTransactionBlock({
        transactionBlock: bytes,
        signature: zkSignature,
        options: {
          showObjectChanges: true,
          showEffects: true,
          showEvents: true,
          showInput: true,
        },
      });
    } catch (error) {
      throw new Error(error);
    }
  };

  /**
   * transfer coin
   * @param to recipient wallet address
   * @param balance amount to transfer
   * @param coin coin to transfer
   * @returns Response Schema
   * */
  transferCoins = async (
    to: string,
    balance: number,
    coin: TRANSFERABLE_COINS
  ): Promise<ResponseSchema> => {
    return this.contractCalls.transferCoins(to, balance, coin);
  };

  /**
   * transfer coin
   * @param to recipient wallet address
   * @param balance amount to transfer
   * @param coinObject
   * @param dryRun
   * @returns Response Schema
   * */
  transferCoinObjects = async (
    to: string,
    balance: number,
    coinObject: {
      balance: string;
      coinObjectIds: string[];
      coinType: string;
      decimals: number;
    },
    dryRun = false
  ): Promise<ResponseSchema> => {
    return this.contractCalls.transferCoinObjects(
      to,
      balance,
      coinObject,
      dryRun
    );
  };

  /**
   * estimate gas for sui token transfer
   * @param to recipient wallet address
   * @param balance amount to transfer
   * @returns BigInt
   * */
  estimateGasForSuiTransfer = async (
    to: string,
    balance: number
  ): Promise<BigInt> => {
    return this.contractCalls.estimateGasForSuiTransfer(to, balance);
  };

  /**
   * estimate gas for usdc token transfer
   * @param to recipient wallet address
   * @param balance amount to transfer
   * @returns BigInt
   * */
  estimateGasForUsdcTransfer = async (
    to: string,
    balance: number
  ): Promise<BigInt> => {
    return this.contractCalls.estimateGasForUsdcTransfer(to, balance);
  };

  /// // ******************* Vault APIs *****************/////
  /**
   * @description
   * Gets deployment json from vaultConfig table
   * @returns deployment json
   * */
  private getVaultConfigsForInteractor = async (): Promise<any> => {
    try {
      if (this.network.vaultURL) {
        // Fetch data from the given URL
        const response = await this.apiService.get<any>(
          VAULT_URLS.VAULT.CONFIG,
          {},
          { isAuthenticationRequired: false },
          this.network.vaultURL
        );
        // The data property of the response object contains our configuration
        return response.data?.[0]?.config;
      }
    } catch (error) {
      // If Axios threw an error, it will be stored in error.response
      if (error.response) {
        throw new Error(`Failed to fetch deployment: ${error.response.status}`);
      } else {
        throw new Error(`An error occurred: ${error}`);
      }
    }
  };

  /**
   * @description
   * Gets user's vault details
   * @returns user vault details
   * */
  public getUserVaultDetails = async (
    userAddress: string,
    vaultId: string
  ): Promise<UserVaultDetail[]> => {
    try {
      // Fetch data from the given URL
      const response = await this.apiService.get<UserVaultDetail[]>(
        VAULT_URLS.USER.VAULT_USER,
        {
          userAddress,
          vaultId,
        },
        { isAuthenticationRequired: false },
        this.network.vaultURL
      );
      // The data property of the response object contains our configuration
      return response.data;
    } catch (error) {
      // If Axios threw an error, it will be stored in error.response
      if (error.response) {
        throw new Error(
          `Failed to fetch user vault detail: ${error.response.status}`
        );
      } else {
        throw new Error(`An error occurred: ${error}`);
      }
    }
  };

  /**
   * @description
   * Gets user's vault details
   * @returns user vault details
   * */
  public getVaultDetails = async (vaultId: string): Promise<VaultDetail> => {
    try {
      // Fetch data from the given URL
      const response = await this.apiService.get<VaultDetail>(
        VAULT_URLS.VAULT.DETAILS,
        {
          vaultId,
        },
        { isAuthenticationRequired: false },
        this.network.vaultURL
      );
      // The data property of the response object contains our configuration
      return response.data;
    } catch (error) {
      // If Axios threw an error, it will be stored in error.response
      if (error.response) {
        throw new Error(
          `Failed to fetch vault detail: ${error.response.status}`
        );
      } else {
        throw new Error(`An error occurred: ${error}`);
      }
    }
  };

  /**
   * @description
   * Gets vault pending withdraw requests
   * @returns pending withdraw requests
   * */
  public getPendingWithdrawRequests = async (
    vaultId: string,
    startTime?: string,
    endTime?: number
  ): Promise<UserPendingWithdrawRequest> => {
    try {
      // Fetch data from the given URL
      const response = await this.apiService.get<UserPendingWithdrawRequest>(
        VAULT_URLS.VAULT.PENDING_WITHDRAW_REQUESTS,
        { vaultId, startTime, endTime },
        { isAuthenticationRequired: false },
        this.network.vaultURL
      );
      // The data property of the response object contains our configuration
      return response.data;
    } catch (error) {
      // If Axios threw an error, it will be stored in error.response
      if (error.response) {
        throw new Error(
          `Failed to fetch vault pending withdraw requests: ${error.response.status}`
        );
      } else {
        throw new Error(`An error occurred: ${error}`);
      }
    }
  };

  /**
   * @description
   * Gets user vault details summary
   * @returns pending withdraw requests
   * */
  public getUserVaultDetailsSummary = async (
    userAddress: string
  ): Promise<UserVaultDetailSummary[]> => {
    try {
      // Fetch data from the given URL
      const response = await this.apiService.get<UserVaultDetailSummary[]>(
        VAULT_URLS.USER.VAULT_USER_SUMMARY,
        { userAddress },
        { isAuthenticationRequired: false },
        this.network.vaultURL
      );
      // The data property of the response object contains our configuration
      return response.data;
    } catch (error) {
      // If Axios threw an error, it will be stored in error.response
      if (error.response) {
        throw new Error(
          `Failed to fetch user vault summary data: ${error.response.status}`
        );
      } else {
        throw new Error(`An error occurred: ${error}`);
      }
    }
  };

  /**
   * @description
   * withdraws USDC from Vault Bank
   * @param amount amount of USDC to withdraw
   * @returns ResponseSchema
   */
  withdrawFromVault = async (
    vaultName: string,
    amount?: number
  ): Promise<ResponseSchema> => {
    if (amount) {
      return this.interactorCalls.withdrawFromVaultContractCall(
        amount,
        vaultName
      );
    }
  };

  /**
   * @description
   * deposit USDC to Vault Bank
   * @param amount amount of USDC to withdraw
   * @returns ResponseSchema
   */
  depositToVault = async (
    vaultName: string,
    amount?: number,
    coinId?: string
  ): Promise<ResponseSchema> => {
    try {
      if (amount) {
        return this.interactorCalls.depositToVaultContractCall(
          amount,
          vaultName
        );
      }
    } catch (e) {
      throw new Error(e);
    }
  };

  /**
   * @description
   * claim all vaults in batch contract call
   * @param batch array containing SignaturePayload and user's signature
   * @returns ResponseSchema
   */
  claimFromVaultBatch = async (
    batch: BatchClaimPayload[]
  ): Promise<ResponseSchema> => {
    return this.interactorCalls.claimFundsFromVaultBatchContractCall(batch);
  };

  /**
   * @description
   * claim USDC from Vault Bank
   * @param amount amount of USDC to withdraw
   * @returns ResponseSchema
   */
  claimFromVault = async (
    vaultName: string,
    signaturePayload: SignaturePayload,
    signature: string
  ): Promise<ResponseSchema> => {
    return this.interactorCalls.claimFundsFromVaultContractCall(
      vaultName,
      signaturePayload,
      signature
    );
  };

  /**
   * @description
   * claim rewards from reward pool
   * @returns ResponseSchema
   */
  claimRewards = async (
    batch: {
      payload: SignaturePayload;
      signature: string;
    }[]
  ): Promise<ResponseSchema> => {
    const response =
      await this.interactorCalls.claimRewardsFromRewardPoolContractCall(batch);

    const events = Transaction.getEvents(response.data, "RewardsClaimedEvent");
    const transformedArray = this.transformPoolId(events);

    const resp = await this.apiService.post<string>(
      SERVICE_URLS.GROWTH.MARK_STATUS_CLAIMED,
      {
        markClaimableEvent: transformedArray,
        txDigest: response.data.digest,
      },
      { isAuthenticationRequired: true }
    );
    return response;
  };

  /**
   * @description
   * Gets vault TVL graph data
   * @returns pending withdraw requests
   * */
  public getVaultTVL = async (
    vaultName: string,
    endTime?: number,
    intervals?: Array<VaultTVLInterval>
  ): Promise<IVaultsTVLDatapointsMap> => {
    try {
      // Fetch data from the given URL
      const response = await this.apiService.get<IVaultsTVLDatapointsMap>(
        VAULT_URLS.USER.VAULT_TVL_GRAPH_DATA,
        { vaultName, endTime, intervals },
        { isAuthenticationRequired: false },
        this.network.vaultURL
      );
      // The data property of the response object contains our configuration
      return response.data;
    } catch (error) {
      // If Axios threw an error, it will be stored in error.response
      if (error.response) {
        throw new Error(
          `Failed to fetch user vault summary data: ${error.response.status}`
        );
      } else {
        throw new Error(`An error occurred: ${error}`);
      }
    }
  };

  private transformPoolId = (
    arr: { [key: string]: any }[]
  ): { [key: string]: any }[] => {
    return arr.map((obj) => {
      // Create a new object to avoid mutating the original object
      const newObj = { ...obj };

      // Check if the property exists in the object
      if (newObj.pool_id !== undefined) {
        // Rename the property
        newObj.poolID = newObj.pool_id;
        delete newObj.pool_id; // Optionally remove the old property
      }

      return newObj;
    });
  };
}
export const SERVICE_URLS = {
  MARKET: {
    ORDER_BOOK: "/orderbook",
    RECENT_TRADE: "/recentTrades",
    CANDLE_STICK_DATA: "/candlestickData",
    EXCHANGE_INFO: "/exchangeInfo",
    MARKET_DATA: "/marketData",
    META: "/meta",
    STATUS: "/status",
    SYMBOLS: "/marketData/symbols",
    CONTRACT_ADDRESSES: "/marketData/contractAddresses",
    TICKER: "/ticker",
    MASTER_INFO: "/masterInfo",
    FUNDING_RATE: "/fundingRate",
    CONFIG: "/config",
  },
  USER: {
    USER_POSITIONS: "/userPosition",
    USER_TRADES: "/userTrades",
    ORDERS: "/orders",
    ACCOUNT: "/account",
    VERIFY_WALLET_STATUS: "/account/verifyWalletStatus",
    USER_TRANSACTION_HISTORY: "/userTransactionHistory",
    AUTHORIZE: "/authorize",
    ADJUST_LEVERAGE: "/account/adjustLeverage",
    FUND_GAS: "/account/fundGas",
    TRANSFER_HISTORY: "/userTransferHistory",
    FUNDING_HISTORY: "/userFundingHistory",
    CANCEL_ON_DISCONNECT: "/dms-countdown",
    GENERATE_READONLY_TOKEN: "/generateReadOnlyToken",
    USER_TRADES_HISTORY: "/userTradesHistory",
    SUBACCOUNT_1CT: "/account/addSubAccountFor1CT",
    EXPIRED_SUBACCOUNT_1CT: "/account/expired1CTAccounts",
    SPONSOR_TX: "/account/sponsorTx",
    OFFCHAIN_SETTLEMENT_UPDATES: "/off-chain-settlement-updates",
  },
  GROWTH: {
    REFERRER_INFO: "/growth/getReferrerInfo",
    CAMPAIGN_DETAILS: "/growth/campaignDetails",
    CAMPAIGN_REWARDS: "/growth/campaignRewards",
    AFFILIATE_PAYOUTS: "/growth/affiliate/payouts",
    AFFILIATE_REFEREE_DETAILS: "/growth/affiliate/refereeDetails",
    AFFILIATE_REFEREES_COUNT: "/growth/refereesCount",
    USER_REWARDS_HISTORY: "/growth/userRewards/history",
    USER_REWARDS_SUMMARY: "/growth/userRewards/summary",
    REWARDS_OVERVIEW: "/growth/tradeAndEarn/rewardsOverview",
    REWARDS_DETAILS: "/growth/tradeAndEarn/rewardsDetail",
    TOTAL_HISTORICAL_TRADING_REWARDS:
      "/growth/tradeAndEarn/totalHistoricalTradingRewards",
    MAKER_REWARDS_SUMMARY: "/growth/marketMaker/maker-rewards-summary",
    MAKER_REWARDS_DETAILS: "/growth/marketMaker/maker-rewards-detail",
    MAKER_WHITELIST_STATUS: "/growth/marketMaker/whitelist-status",
    GENERATE_CODE: "/growth/generateCode",
    AFFILIATE_LINK_REFERRED_USER: "/growth/affiliate/linkReferee",

    OPEN_REFERRAL_REFEREE_DETAILS: "/growth/openReferral/refereeDetails",
    OPEN_REFERRAL_PAYOUTS: "/growth/openReferral/payoutsHistory",
    OPEN_REFERRAL_GENERATE_CODE: "/growth/generateAutoReferralCode",
    OPEN_REFERRAL_LINK_REFERRED_USER: "growth/openReferral/linkReferee",
    OPEN_REFERRAL_OVERVIEW: "/growth/openReferral/rewardsOverview",
    OPEN_REFERRAL_REFEREES_COUNT: "/growth/refereesCount",
    MARK_STATUS_CLAIMED: "/growth/claims/mark-status-claimed",
  },
  ORDERS: {
    ORDERS: "/orders",
    ORDERS_HASH: "/orders/hash",
    ORDERS_HASH_V2: "/v2/user/orders/hash",
  },
};

export const VAULT_URLS = {
  VAULT: {
    CONFIG: "/vaultDetails/vaultConfigs",
    DETAILS: "/vaultDetails",
    PENDING_WITHDRAW_REQUESTS: "/vaultDetails/vaultPendingWithdrawRequests",
  },

  USER: {
    VAULT_USER: "/userVaultDetails",
    VAULT_USER_SUMMARY: "/userVaultDetailsSummary",
    VAULT_TVL_GRAPH_DATA: "/vaultTVLDatapoints",
  },
};
/* eslint-disable no-unused-vars */
import { Socket, io } from "socket.io-client";
import {
  MarketSymbol,
  SOCKET_EVENTS,
  MARKET_STATUS,
  MinifiedCandleStick,
} from "@firefly-exchange/library-sui";

import {
  GetMarketRecentTradesResponse,
  PlaceOrderResponse,
  GetPositionResponse,
  GetUserTradesResponse,
  GetAccountDataResponse,
  MarketData,
  UserSubscriptionAck,
  TickerData,
  Callbacks,
  OrderSentForSettlementUpdateResponse,
  OrderRequeueUpdateResponse,
  OrderCancellationOnReversionUpdateResponse,
  OrderBookPartialDepth,
} from "../interfaces/routes";

export class Sockets {
  private socketInstance!: Socket;

  private url: string;

  private token: string;

  private callbacks: Callbacks = {};

  private apiToken: string;

  constructor(url: string) {
    this.url = url;
    this.token = "";
    this.apiToken = "";
  }

  createDynamicUrl(dynamicUrl: string, object: any) {
    // eslint-disable-next-line no-restricted-syntax, guard-for-in
    for (const key in object) {
      dynamicUrl = dynamicUrl.replace(`{${key}}`, object[key]);
    }
    return dynamicUrl;
  }

  /**
   * opens socket instance connection
   */
  open() {
    this.socketInstance = io(this.url, {
      transports: ["websocket"],
    });

    this.onConnect();
    this.onDisconnect();
  }

  /**
   * closes the socket instance connection
   */
  close() {
    if (this.socketInstance) {
      this.socketInstance.disconnect();
      this.socketInstance.close();
    }
  }

  subscribeGlobalUpdatesBySymbol(symbol: MarketSymbol): boolean {
    if (!this.socketInstance) return false;
    this.socketInstance.emit("SUBSCRIBE", [
      {
        e: SOCKET_EVENTS.GLOBAL_UPDATES_ROOM,
        p: symbol,
      },
    ]);
    return true;
  }

  unsubscribeGlobalUpdatesBySymbol(symbol: MarketSymbol): boolean {
    if (!this.socketInstance) return false;
    this.socketInstance.emit("UNSUBSCRIBE", [
      {
        e: SOCKET_EVENTS.GLOBAL_UPDATES_ROOM,
        p: symbol,
      },
    ]);
    return true;
  }

  setAuthToken = (token: string) => {
    this.token = token;
  };

  /**
   * Assigns callbacks to desired events
   */
  async listen(event: string, callback: Function): Promise<void> {
    this.callbacks[event] = callback;
  }

  setApiToken = async (apiToken: string) => {
    this.apiToken = apiToken;
  };

  subscribeUserUpdateByToken(callback?: UserSubscriptionAck): boolean {
    if (!this.socketInstance) return false;
    this.socketInstance.emit(
      "SUBSCRIBE",
      [
        {
          e: SOCKET_EVENTS.UserUpdatesRoom,
          rt: this.apiToken ? this.apiToken : "",
          t: this.token,
        },
      ],
      (data: UserSubscriptionAck) => {
        if (callback instanceof Function) callback(data);
      }
    );
    return true;
  }

  unsubscribeUserUpdateByToken(callback?: UserSubscriptionAck): boolean {
    if (!this.socketInstance) return false;
    this.socketInstance.emit(
      "UNSUBSCRIBE",
      [
        {
          e: SOCKET_EVENTS.UserUpdatesRoom,
          rt: this.apiToken ? this.apiToken : "",
          t: this.token,
        },
      ],
      (data: UserSubscriptionAck) => {
        if (callback instanceof Function) callback(data);
      }
    );
    return true;
  }

  subscribeOrderBookDepthStreamBySymbol(
    symbol: MarketSymbol,
    depth = ""
  ): boolean {
    if (!this.socketInstance) return false;
    this.socketInstance.emit("SUBSCRIBE", [
      {
        e: SOCKET_EVENTS.ORDERBOOK_DEPTH_STREAM_ROOM,
        p: symbol,
        d: depth,
      },
    ]);
    return true;
  }

  unsubscribeOrderBookDepthStreamBySymbol(
    symbol: MarketSymbol,
    depth = ""
  ): boolean {
    if (!this.socketInstance) return false;
    this.socketInstance.emit("UNSUBSCRIBE", [
      {
        e: SOCKET_EVENTS.ORDERBOOK_DEPTH_STREAM_ROOM,
        p: symbol,
        d: depth,
      },
    ]);
    return true;
  }

  // Emitted when any price bin on the oderbook is updated.
  onOrderBookUpdate = (cb: ({ orderbook }: any) => void) => {
    this.socketInstance.on(SOCKET_EVENTS.OrderbookUpdateKey, cb);
  };

  onOrderBookPartialDepthUpdate = (
    cb: (payload: OrderBookPartialDepth) => void
  ) => {
    this.socketInstance.on(SOCKET_EVENTS.OrderbookDepthUpdateKey, cb);
  };

  onMarketDataUpdate = (
    cb: ({ marketData }: { marketData: MarketData }) => void
  ) => {
    this.socketInstance.on(SOCKET_EVENTS.MarketDataUpdateKey, cb);
  };

  onMarketHealthChange = (
    cb: ({ status, symbol }: { status: MARKET_STATUS; symbol: string }) => void
  ) => {
    this.socketInstance.on(SOCKET_EVENTS.MarketHealthKey, cb);
  };

  onUserOrderSentForSettlementUpdate = (
    cb: (update: OrderSentForSettlementUpdateResponse) => void
  ) => {
    this.socketInstance.on(SOCKET_EVENTS.OrderSentForSettlementUpdate, cb);
  };

  onUserOrderRequeueUpdate = (
    cb: (update: OrderRequeueUpdateResponse) => void
  ) => {
    this.socketInstance.on(SOCKET_EVENTS.OrderRequeueUpdate, cb);
  };

  onUserOrderCancellationOnReversionUpdate = (
    cb: (update: OrderCancellationOnReversionUpdateResponse) => void
  ) => {
    this.socketInstance.on(SOCKET_EVENTS.OrderCancelledOnReversionUpdate, cb);
  };

  onCandleStickUpdate = (
    symbol: string,
    interval: string,
    cb: (candle: MinifiedCandleStick) => void
  ) => {
    this.socketInstance.on(
      this.createDynamicUrl(SOCKET_EVENTS.GET_LAST_KLINE_WITH_INTERVAL, {
        symbol,
        interval,
      }),
      cb
    );
  };

  onExchangeHealthChange = (
    cb: ({ isAlive }: { isAlive: boolean }) => void
  ) => {
    this.socketInstance.on(SOCKET_EVENTS.ExchangeHealthKey, cb);
  };

  onTickerUpdate = (cb: (tickerData: TickerData[]) => void) => {
    this.socketInstance.on(SOCKET_EVENTS.TickerUpdate, cb);
  };

  // TODO: figure out what it does
  onRecentTrades = (
    cb: ({ trades }: { trades: GetMarketRecentTradesResponse[] }) => void
  ) => {
    this.socketInstance.on(SOCKET_EVENTS.RecentTradesKey, cb);
  };

  onUserOrderUpdate = (
    cb: ({ order }: { order: PlaceOrderResponse }) => void
  ) => {
    this.socketInstance.on(SOCKET_EVENTS.OrderUpdateKey, cb);
  };

  onUserOrderCancellationFailed = (
    cb: ({ order }: { order: PlaceOrderResponse }) => void
  ) => {
    this.socketInstance.on(SOCKET_EVENTS.OrderCancellationFailedKey, cb);
  };

  onUserPositionUpdate = (
    cb: ({ position }: { position: GetPositionResponse }) => void
  ) => {
    this.socketInstance.on(SOCKET_EVENTS.PositionUpdateKey, cb);
  };

  onCustomEvent = (cb: (payload: any) => void, customEventKey: string) => {
    this.socketInstance.on(customEventKey, cb);
  };

  onUserUpdates = (
    cb: ({ trade }: { trade: GetUserTradesResponse }) => void
  ) => {
    this.socketInstance.on(SOCKET_EVENTS.UserTradeKey, cb);
  };

  onUserAccountDataUpdate = (
    cb: ({ accountData }: { accountData: GetAccountDataResponse }) => void
  ) => {
    this.socketInstance.on(SOCKET_EVENTS.AccountDataUpdateKey, cb);
  };

  async onDisconnect(): Promise<void> {
    this.socketInstance.on("disconnect", async () => {
      if (
        "disconnect" in this.callbacks &&
        typeof this.callbacks["disconnect"] === "function"
      ) {
        await this.callbacks["disconnect"]();
      }
    });
  }

  async onConnect(): Promise<void> {
    this.socketInstance.on("connect", async () => {
      if (
        "connect" in this.callbacks &&
        typeof this.callbacks["connect"] === "function"
      ) {
        await this.callbacks["connect"]();
      }
    });
  }
}
/* eslint-disable no-unused-vars */
import {
  MarketSymbol,
  SOCKET_EVENTS,
  MARKET_STATUS,
  MinifiedCandleStick,
} from "@firefly-exchange/library-sui";

import {
  GetMarketRecentTradesResponse,
  PlaceOrderResponse,
  GetPositionResponse,
  GetUserTradesResponse,
  GetAccountDataResponse,
  MarketData,
  TickerData,
  OrderSentForSettlementUpdateResponse,
  OrderRequeueUpdateResponse,
  OrderCancellationOnReversionUpdateResponse,
  OrderBookPartialDepth,
} from "../interfaces/routes";

// @ts-ignore
const WebSocket = require("ws");

const callbackListeners: Record<string, any> = {};
export class WebSockets {
  private socketInstance!: WebSocket;

  private token: string;

  private url: string;

  private apiToken: string;

  constructor(url: string) {
    this.url = url;
    this.token = "";
    this.apiToken = "";
  }

  createDynamicUrl(dynamicUrl: string, object: any) {
    // eslint-disable-next-line no-restricted-syntax, guard-for-in
    for (const key in object) {
      dynamicUrl = dynamicUrl.replace(`{${key}}`, object[key]);
    }
    return dynamicUrl;
  }

  /**
   * opens socket instance connection
   */
  async open() {
    const socket = new WebSocket(this.url);
    this.socketInstance = socket;

    const socketOpenPromise = new Promise(function (resolve, reject) {
      socket.onopen = function () {
        resolve(true);
      };
      socket.onerror = function (err: any) {
        reject(err);
      };
    });

    this.socketInstance.onmessage = (event: any) => {
      event = JSON.parse(event.data);
      if (callbackListeners[event.eventName]) {
        callbackListeners[event.eventName](event.data);
      }
    };

    return socketOpenPromise;
  }

  /**
   * closes the socket instance connection
   */
  close() {
    if (this.socketInstance) {
      this.socketInstance.close();
    }

    Object.keys(callbackListeners).forEach(function (key) {
      delete callbackListeners[key];
    });
  }

  subscribeGlobalUpdatesBySymbol(symbol: MarketSymbol): boolean {
    if (!this.socketInstance) return false;
    this.socketInstance.send(
      JSON.stringify([
        "SUBSCRIBE",
        [
          {
            e: SOCKET_EVENTS.GLOBAL_UPDATES_ROOM,
            p: symbol,
          },
        ],
      ])
    );
    return true;
  }

  unsubscribeGlobalUpdatesBySymbol(symbol: MarketSymbol): boolean {
    if (!this.socketInstance) return false;
    this.socketInstance.send(
      JSON.stringify([
        "UNSUBSCRIBE",
        [
          {
            e: SOCKET_EVENTS.GLOBAL_UPDATES_ROOM,
            p: symbol,
          },
        ],
      ])
    );
    return true;
  }

  subscribeUserUpdateByToken(): boolean {
    if (!this.socketInstance) return false;

    this.socketInstance.send(
      JSON.stringify([
        "SUBSCRIBE",
        [
          {
            e: SOCKET_EVENTS.UserUpdatesRoom,
            rt: this.apiToken ? this.apiToken : "",
            t: this.token,
          },
        ],
      ])
    );
    return true;
  }

  unsubscribeUserUpdateByToken(): boolean {
    if (!this.socketInstance) return false;
    this.socketInstance.send(
      JSON.stringify([
        "UNSUBSCRIBE",
        [
          {
            e: SOCKET_EVENTS.UserUpdatesRoom,
            rt: this.apiToken ? this.apiToken : "",
            t: this.token,
          },
        ],
      ])
    );
    return true;
  }

  subscribeOrderBookDepthStreamBySymbol(
    symbol: MarketSymbol,
    depth = ""
  ): boolean {
    if (!this.socketInstance) return false;
    this.socketInstance.send(
      JSON.stringify([
        "SUBSCRIBE",
        [
          {
            e: SOCKET_EVENTS.ORDERBOOK_DEPTH_STREAM_ROOM,
            p: symbol,
            d: depth,
          },
        ],
      ])
    );
    return true;
  }

  unsubscribeOrderBookDepthStreamBySymbol(
    symbol: MarketSymbol,
    depth = ""
  ): boolean {
    if (!this.socketInstance) return false;
    this.socketInstance.send(
      JSON.stringify([
        "UNSUBSCRIBE",
        [
          {
            e: SOCKET_EVENTS.ORDERBOOK_DEPTH_STREAM_ROOM,
            p: symbol,
            d: depth,
          },
        ],
      ])
    );
    return true;
  }

  setAuthToken = (token: string) => {
    this.token = token;
  };

  setApiToken = async (apiToken: string) => {
    this.apiToken = apiToken;
  };

  // Emitted when any price bin on the oderbook is updated.
  onOrderBookUpdate = (cb: ({ orderbook }: any) => void) => {
    callbackListeners[SOCKET_EVENTS.OrderbookUpdateKey] = cb;
  };

  onMarketDataUpdate = (
    cb: ({ marketData }: { marketData: MarketData }) => void
  ) => {
    callbackListeners[SOCKET_EVENTS.MarketDataUpdateKey] = cb;
  };

  onUserOrderSentForSettlementUpdate = (
    cb: (update: OrderSentForSettlementUpdateResponse) => void
  ) => {
    callbackListeners[SOCKET_EVENTS.OrderSentForSettlementUpdate] = cb;
  };

  onUserOrderRequeueUpdate = (
    cb: (update: OrderRequeueUpdateResponse) => void
  ) => {
    callbackListeners[SOCKET_EVENTS.OrderRequeueUpdate] = cb;
  };

  onUserOrderCancelOnRevertUpdate = (
    cb: (update: OrderCancellationOnReversionUpdateResponse) => void
  ) => {
    callbackListeners[SOCKET_EVENTS.OrderCancelledOnReversionUpdate] = cb;
  };

  onMarketHealthChange = (
    cb: ({ status, symbol }: { status: MARKET_STATUS; symbol: string }) => void
  ) => {
    callbackListeners[SOCKET_EVENTS.MarketHealthKey] = cb;
  };
  onOrderBookPartialDepthUpdate = (
    cb: (payload: OrderBookPartialDepth) => void
  ) => {
    callbackListeners[SOCKET_EVENTS.OrderbookDepthUpdateKey] = cb;
  };

  onCandleStickUpdate = (
    symbol: string,
    interval: string,
    cb: (candle: MinifiedCandleStick) => void
  ) => {
    callbackListeners[
      this.createDynamicUrl(SOCKET_EVENTS.GET_LAST_KLINE_WITH_INTERVAL, {
        symbol,
        interval,
      })
    ] = cb;
  };

  onExchangeHealthChange = (
    cb: ({ isAlive }: { isAlive: boolean }) => void
  ) => {
    callbackListeners[SOCKET_EVENTS.ExchangeHealthKey] = cb;
  };

  onTickerUpdate = (cb: (tickerData: TickerData[]) => void) => {
    callbackListeners[SOCKET_EVENTS.TickerUpdate] = cb;
  };

  // TODO: figure out what it does
  onRecentTrades = (
    cb: ({ trades }: { trades: GetMarketRecentTradesResponse[] }) => void
  ) => {
    callbackListeners[SOCKET_EVENTS.RecentTradesKey] = cb;
  };

  onUserOrderUpdate = (
    cb: ({ order }: { order: PlaceOrderResponse }) => void
  ) => {
    callbackListeners[SOCKET_EVENTS.OrderUpdateKey] = cb;
  };

  onUserPositionUpdate = (
    cb: ({ position }: { position: GetPositionResponse }) => void
  ) => {
    callbackListeners[SOCKET_EVENTS.PositionUpdateKey] = cb;
  };

  onUserUpdates = (
    cb: ({ trade }: { trade: GetUserTradesResponse }) => void
  ) => {
    callbackListeners[SOCKET_EVENTS.UserTradeKey] = cb;
  };

  onUserAccountDataUpdate = (
    cb: ({ accountData }: { accountData: GetAccountDataResponse }) => void
  ) => {
    callbackListeners[SOCKET_EVENTS.AccountDataUpdateKey] = cb;
  };
}
import {
  BigNumberable,
  SuiClient,
  SuiTransactionBlockResponse,
  ZkPayload,
  bnToBaseStr,
  toBaseNumber,
  Transaction,
} from "@firefly-exchange/library-sui";
import { Interactor } from "@firefly-exchange/library-sui/dist/src/blv/interactor";
import interpolate from "interpolate";

import { SignaturePayload } from "@firefly-exchange/library-sui/dist/src/blv/interface";
import { Signer } from "@mysten/sui/cryptography";
import {
  ResponseSchema,
  SuccessMessages,
  TransformToResponseSchema,
} from "./contractErrorHandling.service";
import { BatchClaimPayload } from "../interfaces/routes";

export class InteractorCalls {
  InteractorCalls: Interactor;

  signer: Signer;

  suiClient: SuiClient;

  constructor(
    signer: Signer,
    deployment: any,
    provider: SuiClient,
    isWalletExtension: boolean,
    isZKLogin?: boolean,
    zkPayload?: ZkPayload,
    walletAddress?: string
  ) {
    this.signer = signer;
    this.InteractorCalls = new Interactor(
      provider,
      deployment,
      this.signer,
      isWalletExtension,
      isZKLogin,
      zkPayload,
      walletAddress
    );
  }

  // /**
  //  * @param amount the amount to withdraw
  //  * @param vaultName name of the vault to claim funds from
  //  * @returns ResponseSchema
  //  * @description
  //  * Withdraws funds from the vault
  //  * */
  withdrawFromVaultContractCall = async (
    amount: BigNumberable,
    vaultName: string
  ): Promise<ResponseSchema> => {
    const symbol = vaultName.toLowerCase().includes("blue") ? "BLUE" : "USDC";
    return TransformToResponseSchema(async () => {
      const tx = await this.InteractorCalls.requestWithdrawFromVault(
        vaultName,
        amount
      );

      return tx;
    }, interpolate(SuccessMessages.withdrawFundsFromVault, { amount, symbol }));
  };

  // /**
  //  * @param amount the amount to deposit
  //  * @param vaultName name of the vault to claim funds from
  //  * @returns ResponseSchema
  //  * @description
  //  * Deposit funds to vault
  //  * */
  depositToVaultContractCall = async (
    amount: BigNumberable,
    vaultName: string,
    options?: {
      receiver?: string;
      coinId?: string;
    }
  ): Promise<ResponseSchema> => {
    const symbol = vaultName.toLowerCase().includes("blue") ? "BLUE" : "USDC";

    return TransformToResponseSchema(async () => {
      const tx = await this.InteractorCalls.depositToVault(
        vaultName,
        amount,
        options
      );

      return tx;
    }, interpolate(SuccessMessages.depositToVault, { amount, symbol }));
  };

  // /**
  //  * @param vaultName name of the vault to claim funds from
  //  * @param signaturePayload payload with claim data
  //  * @param signature signature for claim data
  //  * @returns ResponseSchema
  //  * @description
  //  * Withdraws funds from the margin bank contract
  //  * */
  claimFundsFromVaultContractCall = async (
    vaultName: string,
    signaturePayload: SignaturePayload,
    signature: string
  ): Promise<ResponseSchema> => {
    return TransformToResponseSchema(async () => {
      const tx = await this.InteractorCalls.claimFunds(
        vaultName,
        { ...signaturePayload, expiry: "0" },
        signature
      );

      return tx;
    }, interpolate(SuccessMessages.claimFundsFromVault, {}));
  };

  // /**
  //  * @param signaturePayload payload with claim data
  //  * @param signature signature for claim data
  //  * @returns ResponseSchema
  //  * @description
  //  * Withdraws tokens from reward pools
  //  * */
  claimRewardsFromRewardPoolContractCall = async (
    batch: {
      payload: SignaturePayload;
      signature: string;
    }[]
  ): Promise<ResponseSchema> => {
    return TransformToResponseSchema(async () => {
      const tx = await this.InteractorCalls.claimRewardsBatch(batch);
      return tx;
    }, interpolate(SuccessMessages.claimRewardsFromRewardPool, {}));
  };

  // /**
  //  * @param vaultName name of the vault to claim funds from
  //  * @param signaturePayload payload with claim data
  //  * @param signature signature for claim data
  //  * @returns ResponseSchema
  //  * @description
  //  * Withdraws funds from the margin bank contract
  //  * */
  claimFundsFromVaultBatchContractCall = async (
    batch: BatchClaimPayload[]
  ): Promise<ResponseSchema> => {
    const amount = batch.reduce((b, { payload, vaultName }) => {
      const isBlueVault = vaultName.toLowerCase().includes("blue");
      return b + +(isBlueVault ? "0" : payload.amount);
    }, 0);

    const blueAmount = batch.reduce((b, { payload, vaultName }) => {
      const isBlueVault = vaultName.toLowerCase().includes("blue");
      return b + +(!isBlueVault ? "0" : payload.amount);
    }, 0);

    const usdamountStr = `${bnToBaseStr(amount, 2, 6)} USDC`;
    const blueAmountStr = `${bnToBaseStr(blueAmount, 2, 9)} BLUE`;
    let amountStr: string;
    if (amount && !(blueAmount > 0)) {
      amountStr = usdamountStr;
    }
    if (blueAmount > 0 && !(amount > 0)) {
      amountStr = blueAmountStr;
    }
    if (blueAmount > 0 && amount > 0) {
      amountStr = `${usdamountStr} and ${blueAmountStr}`;
    }
    return TransformToResponseSchema(async () => {
      const tx = await this.InteractorCalls.claimFundsBatch(batch);
      return tx;
    }, interpolate(SuccessMessages.claimFundsFromVault, { amount: amountStr }));
  };

  // /**
  //  * @param amount the amount to withdraw
  //  * @param vaultName name of the vault to claim funds from
  //  * @returns ResponseSchema
  //  * @description
  //  * Withdraws funds from the margin bank contract
  //  * */
  withdrawProfitFromVaultContractCall = async (
    vaultName: string,
    amount: string
  ): Promise<ResponseSchema> => {
    return TransformToResponseSchema(async () => {
      const tx =
        await this.InteractorCalls.moveProfitWithdrawalFundsToHoldingAccount(
          vaultName,
          amount
        );

      return tx;
    }, interpolate(SuccessMessages.withdrawMargin, { amount }));
  };
}
import {
  getValue,
  SuiTransactionBlockResponse,
  Transaction,
  TransactionBlock,
} from "@firefly-exchange/library-sui/";
import { serializeError } from "eth-rpc-errors";
import { DryRunTransactionBlockResponse } from "@firefly-exchange/library-sui";

const lockErrorRetryDelayMS = 2000;
const lockErrorMaxRetries = 5;

export const LOCKED_ERROR_MESSAGE =
  "Failed to sign transaction by a quorum of validators because of locked objects";
export type ResponseSchema = {
  ok: boolean;
  data: any;
  message: string;
  code?: number | string;
  stack?: string;
};
interface ProviderRpcError {
  code: number | string;
  message: string;
  data?: unknown;
  stack?: string;
}
export const handleResponse = (
  response: ProviderRpcError,
  ok: boolean
): ResponseSchema => {
  const mutatedResponse: ResponseSchema = {
    ok,
    data: getValue(
      response.data as object,
      "originalError.transaction",
      response.data
    ),
    message: getValue(
      response.data as object,
      "originalError.reason",
      response.message
    ),
    code: getValue(
      response.data as object,
      "originalError.code",
      response.code
    ),
    stack: response.message,
  };
  return mutatedResponse;
};

export const TransformToResponseSchema = async (
  contactCall: () => Promise<
    | SuiTransactionBlockResponse
    | DryRunTransactionBlockResponse
    | TransactionBlock
  >,
  successMessage: string,
  isSponsored?: boolean
): Promise<ResponseSchema> => {
  for (let retryNo = 0; retryNo < lockErrorMaxRetries; retryNo++) {
    if (!isSponsored) {
      const tx = await (contactCall() as Promise<SuiTransactionBlockResponse>);
      if (Transaction.getStatus(tx) === "success") {
        return handleResponse(
          {
            data: tx,
            message: successMessage,
            code: 200,
          },
          true
        );
      }
      return handleResponse(
        {
          data: tx,
          message: Transaction.getError(tx),
          code: 400,
        },
        false
      );
    }
    const res = await (contactCall() as unknown as TransactionBlock);
    const obj = {
      data: res,
      code: 200,
      message: "",
      ok: true,
    };
    return obj;
  }
};

export enum SuccessMessages {
  adjustLeverage = "Leverage Adjusted to {leverage}x.",
  adjustMarginAdd = "{amount} USDC margin Added to position.",
  adjustMarginRemove = "{amount} USDC margin Removed from position.",
  withdrawMargin = "{amount} USDC withdrawn.",
  claimFundsFromVault = "{amount} claimed from vault.",
  claimRewardsFromRewardPool = "Rewards claimed from reward pool.",
  withdrawFundsFromVault = "{amount} {symbol} withdraw request sent to pool.",
  approveUSDC = "{amount} USDC approved.",
  depositToBank = "{amount} USDC deposited to Margin Bank.",
  depositToVault = "{amount} {symbol} deposited to pool.",
  setSubAccounts = "This {address} is successfully {status} as a subaccount",
  transferCoins = "{balance} {coin} transferred to {walletAddress}",
}

export enum VerificationStatus {
  Success = "success",
  Restricted = "restricted",
  Blocked = "blocked",
}

export enum APIErrorMessages {
  // eslint-disable-next-line max-len
  restrictedUser = "This wallet address has been identified as high-risk. You will not be able to open any new positions or deposit funds on the exchange. You may, however, close out any open positions and withdraw free collateral",
}

export enum VaultTVLInterval {
  DAY = "TWENTY_MINUTES",
  WEEK = "THREE_HOURS",
  MONTH = "TWELVE_HOURS",
  ALL = "FOUR_DAYS",
}
import axios, { AxiosRequestConfig, AxiosResponse, AxiosInstance } from "axios";
import { getValue, isEmpty } from "@firefly-exchange/library-sui";
import { ResponseSchema } from "./contractErrorHandling.service";
import { version as currentVersion } from "../../package.json";
import { SERVICE_URLS } from "./apiUrls";
import { ExtendedNetwork } from "../interfaces/routes";

export class APIService {
  private apiService: AxiosInstance;

  private token: string | undefined = undefined;

  private apiToken: string | undefined = undefined;

  private walletAddress: string | undefined = undefined;

  private baseUrl: string | undefined = undefined;

  private uuid: string = "";

  private uiWalletType: string = "";

  private network: ExtendedNetwork;

  constructor(url: string, uiWalletType?: string, network?: ExtendedNetwork) {
    this.baseUrl = url;
    this.apiService = axios.create({
      headers: {
        "Content-Type": "application/json",
        "x-bluefin-client-version": currentVersion,
      },
      validateStatus: () => true,
    });
    this.uiWalletType = uiWalletType;
    this.network = network;
  }

  async get<T>(
    url: string,
    queryParams?: object,
    config?: AxiosRequestConfig & { isAuthenticationRequired?: boolean },
    baseUrl?: string
  ) {
    if (!baseUrl) baseUrl = this.baseUrl;
    url = baseUrl + url;
    const response = await this.apiService.get(url, {
      params: queryParams,
      ...config,
      transformRequest: config?.isAuthenticationRequired
        ? this.transformRequest
        : undefined,
    });
    return this.handleResponse<T>(response);
  }

  async post<T>(
    url: string,
    data: object,
    config?: AxiosRequestConfig & { isAuthenticationRequired?: boolean },
    baseUrl?: string
  ) {
    const endpoint = url;
    if (!baseUrl) baseUrl = this.baseUrl;
    url = baseUrl + url;

    const response = await this.apiService.post(url, data, {
      ...config,
      transformRequest: config?.isAuthenticationRequired
        ? this.transformRequest
        : endpoint == SERVICE_URLS.USER.AUTHORIZE
        ? this.transformAuthRequest
        : undefined,
    });
    return this.handleResponse<T>(response);
  }

  async put<T>(
    url: string,
    data: object,
    config?: AxiosRequestConfig & { isAuthenticationRequired?: boolean },
    baseUrl?: string
  ) {
    if (!baseUrl) baseUrl = this.baseUrl;
    url = baseUrl + url;
    const response = await this.apiService.put(url, data, {
      ...config,
      transformRequest: config?.isAuthenticationRequired
        ? this.transformRequest
        : undefined,
    });
    return this.handleResponse<T>(response);
  }

  async patch<T>(
    url: string,
    data: object,
    config?: AxiosRequestConfig & { isAuthenticationRequired?: boolean },
    baseUrl?: string
  ) {
    if (!baseUrl) baseUrl = this.baseUrl;
    url = baseUrl + url;
    const response = await this.apiService.patch(url, data, {
      ...config,
      transformRequest: config?.isAuthenticationRequired
        ? this.transformRequest
        : undefined,
    });
    return this.handleResponse<T>(response);
  }

  async delete<T>(
    url: string,
    data: object,
    config?: AxiosRequestConfig & { isAuthenticationRequired?: boolean },
    baseUrl?: string
  ) {
    if (!baseUrl) baseUrl = this.baseUrl;
    url = baseUrl + url;
    const response = await this.apiService.delete(url, {
      ...config,
      data,
      transformRequest: config?.isAuthenticationRequired
        ? this.transformRequest
        : undefined,
    });
    return this.handleResponse<T>(response);
  }

  setAuthToken = async (token: string) => {
    this.token = token;
  };

  setUUID = async (uuid: string) => {
    this.uuid = uuid;
  };

  setApiToken = async (apiToken: string) => {
    this.apiToken = apiToken;
  };

  setWalletAddress = async (address: string) => {
    this.walletAddress = address;
  };
  //= ==============================================================//
  //                    PRIVATE HELPER FUNCTIONS
  //= ==============================================================//

  private transformRequest = (data: any, headers?: any) => {
    if (this.apiToken) {
      headers["x-api-token"] = this.apiToken;
    } else {
      headers.Authorization = `Bearer ${this.token}`;
    }
    if (this.uuid) {
      headers["x-mm-id"] = this.uuid;
    }

    headers["x-wallet-address"] = this.walletAddress || "";
    return JSON.stringify(data);
  };

  private transformAuthRequest = (data: any, headers?: any) => {
    headers["x-wallet-address"] = this.walletAddress || "";
    if (this.uiWalletType) {
      headers["x-ui-wallet-type"] = this.uiWalletType;
    }
    if (this.network) {
      headers["x-signed-payload"] = this.network.onboardingUrl;
    }
    return JSON.stringify(data);
  };

  // TODO; create interface for response
  private handleResponse<T>(response: AxiosResponse<any>) {
    const mutatedResponse = {
      // TODO:needs to be implemented properly (BE have to change response model first )
      ok:
        response.statusText === "OK" ||
        (response.status >= 200 && response.status < 300),
      status: response.status,
      response: {
        data: getValue(response.data, "error.data", response.data),
        message: getValue(response.data, "error.message", "success"),
        errorCode: getValue(response.data, "error.code", null),
      },
    };

    const data: T = getValue(response, "data", undefined);

    if (mutatedResponse.ok) {
      return { ...mutatedResponse, data };
    }
    return {
      ...mutatedResponse,
      data: !isEmpty(data) ? data : undefined,
    };
  }

  public transformAPItoResponseSchema(APIResponse: any): ResponseSchema {
    const mutatedResponse = {
      ok: APIResponse.ok,
      data: APIResponse.response.data,
      message: APIResponse.response.message,
      code: APIResponse.status,
    };
    return mutatedResponse;
  }
}
import {
  address,
  ADJUST_MARGIN,
  OnChainCalls,
  SignatureWithBytes,
  SuiClient,
  SuiTransactionBlockResponse,
  toBaseNumber,
  toBigNumberStr,
  Transaction,
  TransactionBlock,
  TRANSFERABLE_COINS,
  ZkPayload,
} from "@firefly-exchange/library-sui";
import { Signer } from "@mysten/sui/cryptography";
import interpolate from "interpolate";
import {
  ResponseSchema,
  SuccessMessages,
  TransformToResponseSchema,
} from "./contractErrorHandling.service";
import { combineAndEncode, throwCustomError } from "../../utils/utils";
import { Errors } from "../constants";

export class ContractCalls {
  onChainCalls: OnChainCalls;

  signer: Signer;

  suiClient: SuiClient;

  marginBankId: string | undefined;

  walletAddress: string;

  is_wallet_extension: boolean;

  constructor(
    signer: Signer,
    deployment: any,
    provider: SuiClient,
    is_zkLogin: boolean,
    zkPayload?: ZkPayload,
    walletAddress?: string,
    is_wallet_extension?: boolean
  ) {
    this.signer = signer;
    this.signer.toSuiAddress = this.signer.toSuiAddress
      ? this.signer.toSuiAddress
      : // @ts-ignore
        () => this.signer.address;

    this.walletAddress = walletAddress || signer.toSuiAddress();
    this.is_wallet_extension = is_wallet_extension;
    this.onChainCalls = new OnChainCalls(
      this.signer,
      deployment,
      provider,
      is_zkLogin,
      zkPayload,
      walletAddress,
      is_wallet_extension
    );
  }

  /**
   * Withdraws funds from the margin bank contract
   * @param amount the amount to withdraw
   * @returns ResponseSchema
   * */
  withdrawFromMarginBankContractCall = async (
    amount: Number,
    sponsor?: boolean
  ): Promise<ResponseSchema> => {
    return TransformToResponseSchema(async () => {
      const tx = await this.onChainCalls.withdrawFromBank(
        {
          amount: toBigNumberStr(amount.toString(), 6),
          accountAddress: this.walletAddress,
          sponsor,
        },
        this.signer
      );

      if (tx && !this.marginBankId) {
        if (sponsor) {
          // TODO: fix marginBankId if sponsor
          this.marginBankId = Transaction.getBankAccountID(
            tx as SuiTransactionBlockResponse
          );
        } else {
          this.marginBankId = Transaction.getBankAccountID(
            tx as SuiTransactionBlockResponse
          );
        }
      }
      return tx;
    }, interpolate(SuccessMessages.withdrawMargin, { amount }));
  };

  /**
   * Withdraws all funds from the margin bank contract
   * @returns ResponseSchema
   * */
  withdrawAllFromMarginBankContractCall = async (): Promise<ResponseSchema> => {
    return TransformToResponseSchema(async () => {
      const r = await this.onChainCalls.withdrawAllMarginFromBank(
        this.signer,
        this.walletAddress
      );
      return r;
    }, interpolate(SuccessMessages.withdrawMargin, { amount: "all" }));
  };

  /**
   * Deposits funds to the margin bank contract
   * @param amount the amount to deposit
   * @param coinID the coinID to deposit
   * @returns ResponseSchema
   * */
  depositToMarginBankContractCall = async (
    amount: number,
    coinID: string,
    getPublicAddress: () => address,
    sponsor?: boolean
  ): Promise<ResponseSchema> => {
    try {
      return TransformToResponseSchema(async () => {
        const tx = await this.onChainCalls.depositToBank(
          {
            amount: toBigNumberStr(amount.toString(), 6),
            coinID,
            bankID: this.onChainCalls.getBankID(),
            accountAddress: this.walletAddress || getPublicAddress(),
            sponsor,
          },
          this.signer
        );
        if (tx && !this.marginBankId) {
          if (sponsor) {
            this.marginBankId = Transaction.getBankAccountID(
              tx as SuiTransactionBlockResponse
            );
          } else {
            this.marginBankId = "";
          }
        }
        return tx;
      }, interpolate(SuccessMessages.depositToBank, { amount }));
    } catch (error) {
      throwCustomError({
        error,
        code: Errors.DEPOSIT_TO_BANK_CONTRACT_CALL_FAILED,
      });
    }
  };

  /**
   * Deposits funds to the margin bank contract
   * @param amount the amount to deposit
   * @returns ResponseSchema
   * */
  getUSDCHavingBalance = async (amount: number) => {
    try {
      return await this.onChainCalls.getUSDCoinHavingBalance(
        {
          amount,
          address: this.walletAddress,
        },
        this.signer
      );
    } catch (error) {
      throwCustomError({
        error,
        code: Errors.FAILED_TO_FETCH_USDC_COIN_HAVING_BALANCE,
      });
    }
  };

  /**
   * Deposits funds to the margin bank contract
   * @param walletAddress user wallet address
   * @returns ResponseSchema
   * */
  getUSDCCoins = async (walletAddress: string) => {
    try {
      return await this.onChainCalls.getUSDCCoins(
        { address: walletAddress },
        this.signer
      );
    } catch (error) {
      throwCustomError({
        error,
        code: Errors.FAILED_TO_FETCH_USDC_COINS,
      });
    }
  };

  /**
   * Deposits funds to the margin bank contract
   * @param sponsor is the tx sponsored or not
   * @returns ResponseSchema
   * */
  mergeAllUSDCCOins = async (sponsor?: boolean) => {
    try {
      return await this.onChainCalls.mergeAllUsdcCoins(
        this.onChainCalls.getCoinType(),
        this.signer,
        this.walletAddress,
        sponsor
      );
    } catch (error) {
      throwCustomError({
        error,
        code: Errors.FAILED_TO_MERGE_USDC_COINS,
      });
    }
  };

  /**
   * adjusts the leverage of the desiered position
   * @param leverage the leverage to set
   * @param symbol the position's market symbol
   * @returns ResponseSchema
   * */
  adjustLeverageContractCall = async (
    leverage: number,
    symbol: string,
    parentAddress?: string,
    sponsorTx?: boolean
  ): Promise<ResponseSchema> => {
    const perpId = this.onChainCalls.getPerpetualID(symbol);
    return TransformToResponseSchema(
      async () => {
        return await this.onChainCalls.adjustLeverage(
          {
            leverage,
            perpID: perpId,
            account: parentAddress || this.walletAddress,
            market: symbol,
            sponsor: sponsorTx,
          },
          this.signer
        );
      },
      interpolate(SuccessMessages.adjustLeverage, { leverage }),
      sponsorTx
    );
  };

  adjustLeverageContractCallRawTransaction = async (
    leverage: number,
    symbol: string,
    parentAddress?: string
  ): Promise<string> => {
    const perpId = this.onChainCalls.getPerpetualID(symbol);
    const signedTx = await this.onChainCalls.signAdjustLeverage(
      {
        leverage,
        perpID: perpId,
        account: parentAddress || this.walletAddress,
        market: symbol,
      },
      this.signer
    );

    return combineAndEncode({
      bytes: signedTx.bytes,
      signature: signedTx.signature,
    });
  };

  /**
   * This method return the signed Transaction for adding/removing the subaccount(s) on chain
   * @param account The sub account address
   * @param accountsToRemove The array of sub account addresses that need to be removed on-chain (optional param)
   * @param subAccountsMapID The id of the chain object that holds subaccounts mapping (optional param)
   * @param gasBudget The gas budget to be passed to execute the on-chain transaction (optional param)
   * @returns string
   * */
  upsertSubAccountContractCallRawTransaction = async (
    account: string,
    accountsToRemove?: Array<string>,
    subAccountsMapID?: string,
    gasBudget?: number,
    sponsor?: boolean
  ): Promise<string | TransactionBlock> => {
    try {
      const signedTx = await this.onChainCalls.signUpsertSubAccount(
        {
          account,
          accountsToRemove,
          subAccountsMapID,
          gasBudget,
          sponsor,
        },
        this.signer
      );

      if (sponsor) {
        return signedTx as unknown as TransactionBlock;
      }

      return combineAndEncode(signedTx as SignatureWithBytes);
    } catch (error) {
      throwCustomError({
        error,
        code: Errors.SIGN_UPSERT_SUB_ACCOUNT_CONTRACT_CALLED_FAILED,
      });
    }
  };

  /**
   * closes the desiered position
   * @param publicAddress the sub account's public address
   * @param status the status to set for sub account true = add, false = remove
   * @returns ResponseSchema
   * */

  setSubAccount = async (
    publicAddress: address,
    status: boolean,
    sponsor?: boolean
  ): Promise<ResponseSchema> => {
    return TransformToResponseSchema(async () => {
      return await this.onChainCalls.setSubAccount(
        {
          account: publicAddress,
          status,
          sponsor,
        },
        this.signer
      );
    }, interpolate(SuccessMessages.setSubAccounts, { address: publicAddress, status: status ? "added" : "removed" }));
  };

  /**
   * adjusts the margin of the desiered position
   * @param symbol the position's market symbol
   * @operationType the operation type to perform (add or remove)
   * @amount the amount to add or remove
   * @returns Response Schemea
   * */
  adjustMarginContractCall = async (
    symbol: string,
    operationType: ADJUST_MARGIN,
    amount: number,
    sponsorTx?: boolean
  ): Promise<ResponseSchema> => {
    const perpId = this.onChainCalls.getPerpetualID(symbol);
    const msg =
      operationType === ADJUST_MARGIN.Add
        ? interpolate(SuccessMessages.adjustMarginAdd, { amount })
        : interpolate(SuccessMessages.adjustMarginRemove, { amount });
    return TransformToResponseSchema(
      async () => {
        if (operationType === ADJUST_MARGIN.Add) {
          if (sponsorTx) {
            return this.onChainCalls.addMargin(
              {
                amount,
                perpID: perpId,
                market: symbol,
                account: this.walletAddress,
                sponsor: true,
              },
              this.signer
            );
          }
          return this.onChainCalls.addMargin(
            {
              amount,
              perpID: perpId,
              market: symbol,
              account: this.walletAddress,
            },
            this.signer
          );
        }
        if (sponsorTx) {
          return this.onChainCalls.removeMargin(
            {
              amount,
              perpID: perpId,
              market: symbol,
              account: this.walletAddress,
              sponsor: true,
            },
            this.signer
          );
        }
        return this.onChainCalls.removeMargin(
          {
            amount,
            perpID: perpId,
            market: symbol,
            account: this.walletAddress,
          },
          this.signer
        );
      },
      msg,
      sponsorTx
    );
  };

  /**
   * Get the margin bank balance
   * @returns number
   * */
  getMarginBankBalance = async (): Promise<number> => {
    if (this.marginBankId) {
      return toBaseNumber(
        (
          await this.onChainCalls.getBankAccountDetailsUsingID(
            this.marginBankId
          )
        ).balance
      );
    }
    return 0;
  };

  /**
   * transfer coins
   * @param to recipient wallet address
   * @param balance amount to transfer
   * @param coin coin to transfer
   * @returns Response Schema
   * */
  transferCoins = async (
    to: string,
    balance: number,
    coin: TRANSFERABLE_COINS
  ): Promise<ResponseSchema> => {
    return TransformToResponseSchema(async () => {
      return await this.onChainCalls.transferCoins(
        {
          to,
          balance,
          coin,
        },
        this.signer
      );
    }, interpolate(SuccessMessages.transferCoins, { balance, coin, walletAddress: to }));
  };

  /**
   * transfer coins
   * @param to recipient wallet address
   * @param balance amount to transfer
   * @param coinObject
   * @param dryRun
   * @returns Response Schema
   * */
  transferCoinObjects = async (
    to: string,
    balance: number,
    coinObject: {
      balance: string;
      coinObjectIds: string[];
      coinType: string;
      decimals: number;
    },
    dryRun = false
  ): Promise<ResponseSchema> => {
    return TransformToResponseSchema(async () => {
      return this.onChainCalls.transferCoinObjects(
        to,
        balance,
        coinObject,
        this.signer,
        dryRun
      );
    }, interpolate(SuccessMessages.transferCoins, { balance, coinObject, walletAddress: to }));
  };

  /**
   * estimate gas for sui token transfer
   * @param to recipient wallet address
   * @param balance SUI amount to transfer
   * @returns Response Schema
   * */

  estimateGasForSuiTransfer = async (
    to: string,
    balance: number
  ): Promise<BigInt> => {
    return await this.onChainCalls.estimateGasForSuiTransfer({
      to,
      balance,
    });
  };

  /**
   * esimate gas for USDC token transfer
   * @param to recipient wallet address
   * @param balance USDC amount to transfer
   * @returns Response Schema
   * */

  estimateGasForUsdcTransfer = async (
    to: string,
    balance: number
  ): Promise<BigInt> => {
    return await this.onChainCalls.estimateGasForUSDCTransfer({
      to,
      balance,
    });
  };

  /**
   * fetch user sui balance
   * @param walletAddress wallet address of the user
   * @returns string
   * */

  getSUIBalance = async (walletAddress?: string): Promise<string> => {
    return await this.onChainCalls.getUserSuiBalance(walletAddress);
  };
}
export const Networks = {
  DEVNET_SUI: {
    name: "devnet",
    url: "https://fullnode.testnet.sui.io:443",
    apiGateway: "https://dapi.api.sui-dev.bluefin.io",
    dmsURL: "https://dapi.api.sui-dev.bluefin.io/dead-man-switch",
    vaultURL: "https://vault.api.sui-dev.bluefin.io",
    socketURL: "wss://dapi.api.sui-dev.bluefin.io",
    webSocketURL: "wss://notifications.api.sui-dev.bluefin.io",
    onboardingUrl: "https://devnet.bluefin.io",
    faucet: "https://faucet.devnet.sui.io",
    UUID: "",
  },
  TESTNET_SUI: {
    name: "testnet",
    url: "https://fullnode.testnet.sui.io:443",
    apiGateway: "https://dapi.api.sui-staging.bluefin.io",
    dmsURL: "https://dapi.api.sui-staging.bluefin.io/dead-man-switch",
    vaultURL: "https://vault.api.sui-staging.bluefin.io",
    socketURL: "wss://dapi.api.sui-staging.bluefin.io",
    webSocketURL: "wss://notifications.api.sui-staging.bluefin.io",
    onboardingUrl: "https://testnet.bluefin.io",
    faucet: "https://faucet.devnet.sui.io",
    UUID: "",
  },
  PRODUCTION_SUI: {
    name: "production",
    url: "https://fullnode.mainnet.sui.io:443",
    apiGateway: "https://dapi.api.sui-prod.bluefin.io",
    socketURL: "wss://dapi.api.sui-prod.bluefin.io",
    dmsURL: "https://dapi.api.sui-prod.bluefin.io/dead-man-switch",
    vaultURL: "https://vault.api.sui-prod.bluefin.io",
    webSocketURL: "wss://notifications.api.sui-prod.bluefin.io",
    onboardingUrl: "https://trade-sui.bluefin.exchange",
    faucet: "does not exist",
    UUID: "",
  },
  PRODUCTION_SUI_INTERNAL: {
    name: "production",
    url: "https://fullnode.mainnet.sui.io:443",
    apiGateway: "https://dapi.api.sui-prod.int.bluefin.io",
    socketURL: "wss://dapi.api.sui-prod.int.bluefin.io",
    dmsURL: "https://dapi.api.sui-prod.int.bluefin.io/dead-man-switch",
    vaultURL: "https://vault.api.sui-prod.int.bluefin.io",
    webSocketURL: "wss://notifications.api.sui-prod.int.bluefin.io",
    onboardingUrl: "https://trade-sui.bluefin.exchange",
    faucet: "does not exist",
    UUID: "",
  },
};

export const SUI_NETWROK = "sui";
export const POST_ORDER_BASE = 18;
export const USER_REJECTED_MESSAGE = "Rejected from user";

export enum Errors {
  WALLET_PAYLOAD_SIGNING_FAILED = "WALLET_SIGNING_FAILED",
  ZK_PAYLOAD_SIGNING_FAILED = "ZK_SIGNING_FAILED",
  KEYPAIR_PAYLOAD_SIGNING_FAILED = "KEYPAIR_SIGNING_FAILED",
  WALLET_TRANSACTION_SIGNING_FAILED = "WALLET_TRANSACTION_SIGNING_FAILED",
  ZK_TRANSACTION_SIGNING_FAILED = "ZK_TRANSACTION_SIGNING_FAILED",
  KEYPAIR_TRANSACTION_SIGNING_FAILED = "KEYPAIR_TRANSACTION_SIGNING_FAILED",
  EXECUTE_TRANSACTION_FAILED = "EXECUTE_TRANSACTION_FAILED",
  EXECUTE_SPONSORED_TRANSACTION_FAILED = "EXECUTE_SPONSORED_TRANSACTION_FAILED",
  BUILD_GASLESS_PAYLOAD_TX_PAYLOAD_BYTES_FAILED = "BUILD_GASLESS_PAYLOAD_TX_PAYLOAD_BYTES_FAILED",
  DAPI_ERROR = "DAPI_ERROR",
  SIGN_UPSERT_SUB_ACCOUNT_CONTRACT_CALLED_FAILED = "SIGN_UPSERT_SUB_ACCOUNT_CONTRACT_CALLED_FAILED",
  DEPOSIT_TO_BANK_CONTRACT_CALL_FAILED = "DEPOSIT_TO_BANK_CONTRACT_CALL_FAILED",
  FAILED_TO_FETCH_USDC_COIN_HAVING_BALANCE = "FAILED_TO_FETCH_USDC_COIN_HAVING_BALANCE",
  FAILED_TO_FETCH_USDC_COINS = "FAILED_TO_FETCH_USDC_COINS",
  FAILED_TO_MERGE_USDC_COINS = "FAILED_TO_MERGE_USDC_COINS",
  FAILED_TO_INITIALIZE_CLIENT = "FAILED_TO_INITIALIZE_CLIENT",
  FAILED_TO_INITIALIZE_CLIENT_FOR_UI_WALLET = "FAILED_TO_INITIALIZE_CLIENT_FOR_UI_WALLET",
  FAILED_TO_INITIALIZE_CLIENT_FOR_ZK_ACCOUNT = "FAILED_TO_INITIALIZE_CLIENT_FOR_ZK_ACCOUNT",
  UNKNOWN = "UNKNOWN",
}

export enum OffchainOrderUpdateAction {
  sentForSettlement = "SENT_FOR_SETTLEMENT",
  orderRequeued = "REQUEUING_ORDER",
  orderCancelledOnReversion = "CANCELLING_ORDER",
}
import { Errors } from "../constants";

export class CustomError extends Error {
  public code: Errors;
  public error: Error;
  public extra: Record<any, any>;

  constructor(error: Error, code?: Errors, extra?: Record<any, any>) {
    super();
    this.error = error;
    this.code = code || Errors.UNKNOWN;
    this.extra = extra || {};
    Error.captureStackTrace(this, this.constructor); // Captures the stack trace
  }
}

export default CustomError;
import {
  address,
  CANCEL_REASON,
  Interval,
  MARGIN_TYPE,
  MarketSymbol,
  ORDER_SIDE,
  ORDER_STATUS,
  ORDER_TYPE,
  TIME_IN_FORCE,
} from "@firefly-exchange/library-sui";
import { SignaturePayload } from "@firefly-exchange/library-sui/dist/src/blv/interface";
import { OffchainOrderUpdateAction } from "../constants";
import { VaultType } from "@firefly-exchange/library-sui/dist/src";

export interface GetTransactionHistoryRequest {
  symbol?: MarketSymbol; // will fetch orders of provided market
  pageSize?: number; // will get only provided number of orders must be <= 50
  pageNumber?: number; // will fetch particular page records. A single page contains 50 records.
}

export interface GetFundingHistoryRequest {
  symbol?: MarketSymbol; // will fetch orders of provided market
  pageSize?: number; // will get only provided number of orders must be <= 50
  cursor?: number; // will fetch particular page records. A single page contains 50 records.
  parentAddress?: string;
}

export interface GetTransferHistoryRequest {
  pageSize?: number; // will get only provided number of orders must be <= 50
  cursor?: number; // will fetch particular page records. A single page contains 50 records.
  action?: string; // Deposit / Withdraw
}
export interface GetOrderRequest extends GetTransactionHistoryRequest {
  symbol?: MarketSymbol;
  orderId?: number;
  orderHashes?: string[];
  statuses: ORDER_STATUS[]; // status of orders to be fetched
  orderType?: ORDER_TYPE[]; // order type LIMIT / MARKET
  pageSize?: number;
  pageNumber?: number;
  parentAddress?: string;
}

export interface GetPositionRequest extends GetTransactionHistoryRequest {
  parentAddress?: string;
}

export interface RequiredOrderFields {
  symbol: MarketSymbol; // market for which to create order
  price: number; // price at which to place order. Will be zero for a market order
  quantity: number; // quantity/size of order
  side: ORDER_SIDE; // BUY/SELL
  orderType: ORDER_TYPE; // MARKET/LIMIT
  triggerPrice?: number; // optional, send triggerPrice for stop orders
  postOnly?: boolean; // true/false, default is false
  cancelOnRevert?: boolean; // true/false, default is false
  orderbookOnly?: boolean; // true/false, default is true
  timeInForce?: TIME_IN_FORCE; // IOC/GTT by default all orders are GTT
}

export interface OrderSignatureRequest extends RequiredOrderFields {
  leverage?: number; // leverage to take, default is 1
  reduceOnly?: boolean; // reduce only flag is deprecated until further notice. Default is set to false
  salt?: number; // random number for uniqueness of order. Generated randomly if not provided
  expiration?: number; // time at which order will expire. Will be set to 1 month if not provided
  maker?: address; // address of the parent account on behalf user wants to place the order
  isBuy?: boolean;
}

export interface OrderSignatureResponse extends RequiredOrderFields {
  leverage: number;
  reduceOnly: boolean;
  salt: number;
  expiration: number;
  orderSignature: string;
  maker: address;
}

export interface PlaceOrderRequest extends OrderSignatureResponse {
  clientId?: string;
}

export interface PostOrderRequest extends OrderSignatureRequest {
  clientId?: string;
  parentAddress?: string;
}

interface OrderResponse {
  id: number;
  clientId: string;
  requestTime: number;
  cancelReason: CANCEL_REASON;
  orderStatus: ORDER_STATUS;
  hash: string;
  symbol: MarketSymbol;
  orderType: ORDER_TYPE;
  timeInForce: TIME_IN_FORCE;
  userAddress: address;
  side: ORDER_SIDE;
  price: string;
  triggerPrice: string;
  quantity: string;
  leverage: string;
  reduceOnly: boolean;
  expiration: number;
  salt: number;
  filledQty: string;
  avgFillPrice: string;
  createdAt: number;
  updatedAt: number;
  makerFee: string;
  takerFee: string;
  openQty: string;
  cancelOnRevert?: boolean;
}

export interface GetOrderResponse extends OrderResponse {
  fee: string;
  postOnly: boolean;
  cancelOnRevert: boolean;
  triggerPrice: string;
  margin: string;
}

export interface GetOrderResponse extends OrderResponse {
  fee: string;
  postOnly: boolean;
  cancelOnRevert: boolean;
  triggerPrice: string;
  margin: string;
}
export interface PlaceOrderResponse extends OrderResponse {
  postOnly?: boolean;
  cancelOnRevert?: boolean;
}

export interface OrderCancelSignatureRequest {
  symbol: MarketSymbol;
  hashes: string[];
  parentAddress?: string;
}

export interface OrderCancellationRequest extends OrderCancelSignatureRequest {
  signature: string;
}

export type CancelOrder = {
  hash: string;
  reason?: string;
};

export type CancelOrderResponse = {
  message: string;
  data: {
    acceptedForCancelling: CancelOrder[];
    failedCancelling: CancelOrder[];
  };
};

export interface GetOrderbookRequest {
  symbol: MarketSymbol;
  limit: number; // number of bids/asks to retrieve, should be <= 50
}

export interface GetPositionResponse {
  userAddress: address;
  symbol: MarketSymbol;
  marginType: MARGIN_TYPE;
  side: ORDER_SIDE;
  avgEntryPrice: string;
  quantity: string;
  margin: string;
  leverage: string;
  positionSelectedLeverage: string;
  liquidationPrice: string;
  positionValue: string;
  unrealizedProfit: string;
  unrealizedProfitPercent: string;
  midMarketPrice: string;
  oraclePrice?: string;
  indexPrice?: string;
  updatedAt: number;
  createdAt: number;
}

export interface GetOrderBookResponse {
  asks: string[][];
  bids: string[][];
  midPrice: string;
  symbol: MarketSymbol;
  lastUpdatedAt: number;
  orderbookUpdateId: number;
  responseSentAt: number;

  bestBidPrice: string;
  bestBidQty: string;
  bestAskPrice: string;
  bestAskQty: string;
  oraclePrice: string;
  oraclePriceLastUpdateAt: number;
  firstUpdateId?: number;
  lastUpdateId?: number;

  limit?: number;
}

export interface GetUserTradesRequest {
  symbol?: MarketSymbol;
  maker?: boolean;
  fromId?: number;
  startTime?: number;
  endTime?: number;
  pageSize?: number;
  pageNumber?: number;
  type?: ORDER_TYPE;
  parentAddress?: string;
}

export interface GetUserTradesResponse {
  id: number;
  symbol: MarketSymbol;
  commission: string;
  commissionAsset: string;
  maker: boolean;
  orderHash: string;
  side: ORDER_SIDE;
  price: string;
  quantity: string;
  quoteQty: string;
  realizedPnl: string;
  time: number;
  clientId: string;
  orderId: number;
  tradeType: string;
}

export interface GetUserTradesHistoryRequest {
  symbol?: MarketSymbol;
  maker?: boolean;
  fromId?: number;
  startTime?: number;
  endTime?: number;
  limit?: number;
  cursor?: number;
  type?: ORDER_TYPE;
  parentAddress?: string;
}

export interface GetUserTradesHistoryResponse {
  data: GetUserTradesResponse[];
  nextCursor: number;
  isMoreDataAvailable: boolean;
}

export interface MarketAccountData {
  symbol: MarketSymbol;
  positionQtyReduced: string;
  positionQtyReducible: string;
  unrealizedProfit: string;
  positionMargin: string;
  expectedPnl: string;
  selectedLeverage: string;
}

export interface GetAccountDataResponse {
  address: address;
  feeTier: string;
  canTrade: boolean;
  totalPositionMargin: string;
  totalPositionQtyReduced: string;
  totalPositionQtyReducible: string;
  totalExpectedPnl: string;
  totalUnrealizedProfit: string;
  walletBalance: string;
  freeCollateral: string;
  accountValue: string;
  accountDataByMarket: MarketAccountData[];
  updateTime: number;
}

export interface GetUserTransactionHistoryResponse {
  id: number;
  symbol: MarketSymbol;
  commission: string;
  commissionAsset: string;
  maker: boolean;
  side: ORDER_SIDE;
  price: string;
  quantity: string;
  quoteQty: string;
  realizedPnl: string;
  time: number;
  orderHash: string;
  traderType: string;
}

export interface UserTransferHistoryResponse {
  id: number;
  status: string;
  action: string;
  amount: string;
  userAddress: string;
  blockNumber: number;
  latestTxHash: string;
  time: number;
  createdAt: number;
  updatedAt: number;
}

export interface GetUserTransferHistoryResponse {
  data: UserTransferHistoryResponse[];
  nextCursor: number;
  isMoreDataAvailable: boolean;
}

export interface GetFundingRateResponse {
  symbol: MarketSymbol;
  createdAt: number;
  nextTime: number;
  fundingRate: string;
}

export interface UserFundingHistoryResponse {
  id: number;
  symbol: MarketSymbol;
  userAddress: string;
  quantity: string;
  time: number;
  appliedFundingRate: string;
  isFundingRatePositive: boolean;
  payment: string;
  isPaymentPositive: boolean;
  oraclePrice: string;
  side: ORDER_SIDE;
  blockNumber: number;
  isPositionPositive: boolean;
}

export interface GetUserFundingHistoryResponse {
  data: UserFundingHistoryResponse[];
  nextCursor: number;
  isMoreDataAvailable: boolean;
}

export interface GetMarketRecentTradesRequest {
  symbol: MarketSymbol;
  pageSize?: number;
  pageNumber?: number;
  traders?: address;
}

export interface GetMarketRecentTradesResponse {
  symbol: MarketSymbol;
  id: number;
  price: string;
  quantity: string;
  quoteQty: string;
  time: number;
  side: ORDER_SIDE;
}

export interface GetCandleStickRequest {
  symbol: MarketSymbol;
  interval: Interval;
  startTime?: number;
  endTime?: number;
  limit?: number;
}

/* Market Endpoints */
export interface ExchangeInfo {
  symbol: MarketSymbol;
  status: string;
  baseAssetSymbol: string;
  baseAssetName: string;
  quoteAssetSymbol: string;
  quoteAssetName: string;
  maintenanceMarginReq: string;
  initialMarginReq: string;
  stepSize: number;
  tickSize: number;
  minOrderSize: number;
  maxLimitOrderSize: string;
  maxMarketOrderSize: string;
  minOrderPrice: string;
  maxOrderPrice: string;
  defaultMakerFee: string;
  defaultTakerFee: string;
  insurancePoolPercentage: string;
  mtbLong: string;
  mtbShort: string;
  defaultLeverage: string;
  maxAllowedOIOpen: [];
}

export interface MarketData {
  symbol: MarketSymbol;
  lastQty: string;
  lastTime: string;
  lastPrice: string;
  _24hrHighPrice: string;
  _24hrLowPrice: string;
  _24hrVolume: string;
  _24hrQuoteVolume: string;
  _24hrClosePrice: string;
  _24hrOpenPrice: string;
  _24hrCloseTime: string;
  _24hrOpenTime: string;
  _24hrCount: string;
  oraclePrice?: string;
  indexPrice?: string;
  midMarketPrice: string;
  _24hrFirstId: number;
  _24hrLastId: number;
  bestBidPrice: string;
  bestBidQty: string;
  bestAskPrice: string;
  bestAskQty: string;
  lastFundingRate: string;
  nextFundingTime: string;
  time: string;
  _24hrPriceChange: string;
  midMarketPriceDirection: number;
  _24hrPriceChangePercent: string;
  marketPrice: string;
  marketPriceDirection: number;
}

export interface MarketMeta {
  symbol: MarketSymbol;
  domainHash: string;
  onboardingWebsiteUrl: string;
  rpcURI: string;
  networkID: string;
  orderAddress: address;
  liquidationAddress: address;
  perpetualAddress: address;
}

export interface MasterInfoData {
  symbol: string;
  meta: MarketMeta;
  exchangeInfo: ExchangeInfo;
  marketData: MarketData;
}

export interface MasterInfo {
  _24hrTrades: string;
  _24hrVolume: string;
  data: MasterInfoData[];
}

export interface TickerData {
  symbol: MarketSymbol;
  _24hrPriceChange: string;
  _24hrPriceChangePercent: string;
  openTime: number;
  closeTime: number;
  price: string;
  priceDirection: number;
  _24hrVolume: string;
  oraclePrice?: string;
  indexPrice?: string;
}

export interface StatusResponse {
  isAlive: boolean;
  serverTime: number;
}

export interface AuthorizeHashResponse {
  token: string;
}

export interface adjustLeverageRequest {
  symbol: MarketSymbol;
  leverage: number;
  parentAddress?: string;
  signedTransaction?: string;
  sponsorSignature?: string;
  sponsorTx?: boolean;
}
export interface AdjustLeverageResponse {
  symbol: string;
  address: string;
  leverage: string;
  marginType: string;
  maxNotionalValue: string;
}

export interface SubAccountRequest {
  subAccountAddress: string;
  accountsToRemove?: Array<string>;
}

export interface SignedSubAccountRequest extends SubAccountRequest {
  signedTransaction: string;
  sponsorSignature?: string;
}

export interface SubAccountResponse {
  userAddress: string;
  txIndex?: number;
  logIndex?: number;
  blockNumber?: number;
  subAccountAddress: string;
  createdAt?: Date;
  updatedAt?: Date;
  type?: string;
}

export interface Expired1CTSubAccountsResponse {
  /** The list of subaccounts that are expired and their status is active */
  expiredSubAccounts: Array<string>;
}

export interface SponsorTxResponse {
  status: boolean;
  message: string;
  data: {
    expireAtTime: number;
    signature: string;
    txDigest: string;
    txBytes: string;
  };
}

export interface GetOffchainSettlementUpdatesRequest {
  symbol?: MarketSymbol; // will fetch settlements of provided market
  orderHash?: string; // will fetch settlement updates of provided order hash
  action?: OffchainOrderUpdateAction[]; //if not given provides all "SENT_FOR_SETTLEMENT", "REQUEUING_ORDER", "CANCELLING_ORDER" updates
  pageSize?: number; // will get only provided number of records, default is 100
  pageNumber?: number; // will fetch particular page records. A single page contains 50 records.
  parentAddress?: string;
}
export interface OffchainSettlementUpdatesResponse {
  id: number;
  symbol: string;
  orderHash: string;
  userAddress: string;
  quantity: string;
  actionType: OffchainOrderUpdateAction;
  fillId: string;
  isMaker: boolean;
  avgFillPrice: string;
  matchedOrders: MatchedOrderData[];
  createdAt: number;
  updatedAt: number;
  createdAtInMs: number;
  updatedAtInMs: number;
}

export interface GetOffchainSettlementUpdatesResponse {
  data: OffchainSettlementUpdatesResponse[];
  nextCursor: number;
  isMoreDataAvailable: boolean;
}

export interface FundGasResponse {
  message: string;
}

export interface UserSubscriptionAck {
  success: boolean;
  message: string;
}
export interface VerifyWalletStatusResponse {
  verificationStatus: string;
}
export interface CountDown {
  symbol: string;
  countDown: number;
}
export interface PostTimerAttributes {
  countDowns: CountDown[];
  parentAddress?: string;
}
export interface FailedCountDownResetResponse {
  symbol: string;
  reason: string;
}
export interface PostTimerResponse {
  acceptedToReset: string[];
  failedReset: FailedCountDownResetResponse[];
}
export interface GetCountDownsResponse {
  countDowns: CountDown[];
  timestamp: number;
}

export interface NetworkConfigs {
  name?: string;
  rpc?: string;
  faucet?: string;
  url?: string;
}
// adding this here as it's temporary support for socket.io
export interface ExtendedNetwork extends NetworkConfigs {
  apiGateway?: string; // making it optional for backward compatibility
  socketURL?: string;
  onboardingUrl?: string;
  webSocketURL: string;
  dmsURL?: string;
  vaultURL?: string;
  UUID?: string;
}

export interface ConfigResponse {
  deployment: {
    objects: {
      Bank: ObjectDetails;
      package: ObjectDetails;
      Currency?: ObjectDetails;
      BankTable?: ObjectDetails;
      UpgradeCap?: ObjectDetails;
      OrderStatus?: ObjectDetails;
      SubAccounts?: ObjectDetails;
      TreasuryCap?: ObjectDetails;
      SettlementCap?: ObjectDetails;
      FundingRateCap?: ObjectDetails;
      DeleveragingCap?: ObjectDetails;
      CapabilitiesSafe?: ObjectDetails;
      ExchangeAdminCap?: ObjectDetails;
      ExchangeGuardianCap?: ObjectDetails;
    };
    markets: {
      [market: string]: {
        Objects: {
          Perpetual?: ObjectDetails;
          BankAccount?: ObjectDetails;
          PriceOracle?: ObjectDetails;
          PositionsTable?: ObjectDetails;
        };
      };
    };
  };
}

export interface ObjectDetails {
  id: string;
  owner: string;
  dataType: string;
}

export interface GetReferrerInfoResponse {
  isReferee: boolean;
}
export interface GetCampaignDetailsResponse {
  id: number;
  campaignName: string;
  parentCampaignName?: string;
  startDate: string;
  endDate: string;
  isActive: boolean;
  epochDurationSeconds: number;
  config: {
    cashShare: string;
    tokenShare: string;
    shareOfFees: string;
    refereeDiscount: string;
  };
  createdAt: string;
  updatedAt: string;
}

export interface GetCampaignRewardsResponse {
  campaignName: string;
  campaignConfig: {
    cashShare: string;
    tokenShare: string;
    shareOfFees: string;
    refereeDiscount: string;
  };
  cashReward: string;
  tokenReward: string;
}

export interface GetAffiliatePayoutsResponse {
  epStartDate: string;
  epEndDate: string;
  isActive: boolean;
  totalReferralFees: string;
  cashReward: string;
  tokenReward: string;
  epochNumber: string;
}

export interface GetAffiliateRefereeDetailsRequest {
  campaignId: number;
  pageNumber?: number;
  pageSize?: number;
  parentAddress?: string;
}
export interface GetAffiliateRefereeDetailsResponse {
  data: AffiliateRefereeDetailsData[];
  nextCursor: number;
  isMoreDataAvailable: boolean;
}
interface AffiliateRefereeDetailsData {
  userAddress: string;
  lastTraded?: string;
  dateJoined: string;
  feesPaid: string;
}

export interface GetAffiliateRefereeCountResponse {
  referralCode: string;
  referralCount: number;
}

export interface GetUserRewardsHistoryRequest {
  pageSize?: number;
  cursor?: number;
  parentAddress?: string;
}
export interface GetUserRewardsHistoryResponse {
  data: UserRewardsHistoryData[];
  nextCursor: number;
  isMoreDataAvailable: boolean;
}
interface UserRewardsHistoryData {
  programName: string;
  parentProgramName?: string;
  startDate: string;
  endDate: string;
  cashReward: string;
  tokenReward: string;
  isActive: boolean;
  cursor: string;
  epochNumber: string;
}

export interface GetUserRewardsSummaryResponse {
  totalTokenReward: string;
  totalCashReward: string;
  campaignData: RewardsSummaryData[];
}
interface RewardsSummaryData {
  campaignName: string;
  totalCashReward: string;
  totalTokenReward: string;
}

export interface GetTradeAndEarnRewardsOverviewResponse {
  totalHistoricalRewards: string;
  totalActiveRewards: string;
  totalFeePaid: string;
  latestEpochNumber: string;
  latestEpochStart: number;
  latestEpochEnd: number;
  latestEpochTotalFee: string;
  latestEpochTotalRewards: string;
}

export interface GetTradeAndEarnRewardsDetailRequest {
  campaignId: number;
  pageSize?: number;
  cursor?: number;
  parentAddress?: string;
}

export interface GetTradeAndEarnRewardsDetailResponse {
  data: TradeAndEarnRewardsDetailData[];
  nextCursor: string;
  isMoreDataAvailable: boolean;
}
interface TradeAndEarnRewardsDetailData {
  tradingRewards: string;
  feePaid: string;
  cursor: string;
  id: number;
  isActive: boolean;
  startDate: string;
  endDate: string;
  epochNumber: string;
}

export interface GetTotalHistoricalTradingRewardsResponse {
  totalTokenRewards: string;
}

export interface GetMakerRewardsSummaryResponse {
  latestEpochStart: number;
  latestEpochEnd: number;
  latestEpochNumber: string;
  latestEpochTotalRewards: string;
  totalActiveRewards: string;
  totalHistoricalRewards: string;
}
export interface GetMakerRewardDetailsRequest {
  symbol?: string;
  pageSize?: number;
  cursor?: number;
  parentAddress?: string;
}

export interface GetMakerRewardDetailsResponse {
  data: MakerRewardDetailsData[];
  nextCursor: number;
  isMoreDataAvailable: boolean;
}
interface MakerRewardDetailsData {
  latestEpochNumber: string;
  status: string;
  makerVolume: string;
  volumePercentage: string;
  rewardPoolPercentage: string;
  makerRewards: string;
  startDate: string;
  endDate: string;
  cursor: string;
  liquidityScore?: string; // come if symbol provided in request
  uptimePercentage?: string; // come if symbol provided in request
}

export interface GetUserWhiteListStatusForMarketMakerResponse {
  isWhitelist: boolean;
}

export interface GenerateReferralCodeRequest {
  referralCode: string;
  campaignId: number;
}
export interface GenerateReferralCodeResponse {
  referralAddress: string;
  referralCode: string;
  message?: string;
}

export interface LinkReferredUserRequest {
  referralCode: string;
}
export interface LinkReferredUserResponse {
  referralCode: string;
  refereeAddress: string;
  campaignId: number;
  message?: string;
}

export interface MatchedOrderData {
  fillPrice: string;
  quantity: string;
}

export interface OrderSentForSettlementUpdateResponse {
  orderHash: string;
  userAddress: string;
  symbol: string;
  message: string;
  quantitySentForSettlement: string;
  orderQuantity: string;
  isMaker: boolean;
  isBuy: boolean;
  avgFillPrice: string;
  fillId: string;
  timestamp: number;
  matchedOrders: MatchedOrderData[];
}

export interface OrderRequeueUpdateResponse {
  orderHash: string;
  userAddress: string;
  symbol: string;
  message: string;
  isBuy: boolean;
  fillId: string;
  quantitySentForRequeue: string;
  timestamp: number;
}
export interface OrderBookPartialDepth {
  symbol: string;
  orderbookUpdateId: number;
  depth: number;
  asks: string[][];
  bids: string[][];
}

export interface OrderCancellationOnReversionUpdateResponse {
  orderHash: string;
  userAddress: string;
  symbol: string;
  message: string;
  isBuy: boolean;
  fillId: string;
  quantitySentForCancellation: string;
  timestamp: number;
}

export interface Callbacks {
  [event: string]: Function;
}

export type OpenReferralPayout = {
  epochNumber: number;
  epStartDate: string;
  epEndDate: string;
  isActive: true;
  referralPoints: string;
  referralTradeAndEarnPoints: string;
  rewardedPoints: string;
  cursor: string;
};
export type OpenReferralPayoutList = OpenReferralPayout[];

export type OpenReferralOverview = {
  totalHistoricalRewardedPoints: string;
  totalHistoricalRefereePoints: string;
  totalHistoricalReferralPoints: string;
  totalActiveRewardedPoints: string;
  totalActiveRefereePoints: string;
  totalActiveReferralPoints: string;
  latestEpochNumber: number;
  latestEpochStart: string;
  latestEpochEnd: string;
  latestEpochReferralMultiplier: string;
  latestEpochRefereeMultiplier: string;
};
export interface VaultDetail {
  id: string;
  vaultStoreId: string;
  bank: string;
  bankAccount: string;
  claimsManager: string;
  holdingAccount: string;
  operator: string;
  depositPaused: boolean;
  withdrawPaused: boolean;
  claimsPaused: boolean;
  totallockedamount: string;
  maxCap: string;
  coinBalance: string;
  withdrawAmount: string;
  lendingAgreement?: string;
  bankBalance: string;
  vaultName: string;
  APY: number;
  age: string;
  sequenceNumber: number;
  createdAt: Date;
  updatedAt: Date;
}

export interface UserVaultDetail {
  id: number;
  userAddress: string;
  userLockedAmount: string;
  vaultId: string;
  withdrawAmountRequested: string;
  claimableAmount: string;
  claimSignature?: string;
  nonce?: number;
  createdAt?: Date;
  updatedAt?: Date;
  sequenceNumber: number;
}
export interface UserPendingWithdrawRequest {
  distinctUserRequestsCount: number;
  totalWithdrawAmount: number;
}
export interface UserVaultTransferRequest {
  id: number;
  userAddress: string;
  amount: string;
  vaultId: string;
  requestType: "DEPOSIT" | "WITHDRAW";
  requestStatus: "APPROVED" | "CLAIMABLE" | "CLAIMED";
  sequenceNumber: number;
  createdAt?: Date;
  updatedAt?: Date;
}

export interface UserVaultDetailSummary {
  vaultName: string;
  vaultId: string;
  coinDecimal: number;
  vaultType: string;
  APY: string;
  TVL: string;
  vaultTotalVolume: string;
  age: string;
  lendingAgreement: string;
  userLockedAmount: string;
  userWithdrawAmountRequested: string;
  claimableAmount: string;
  communityData?: any[];
  rewardsPool?: number;
  suiRewardPool?: number;
  blueRewardPool?: number;
  withdrawPaused: boolean;
}

export interface VaultConfig {
  id?: number;
  config?: any;
}

export interface IVaultsTVLDatapointsMap {
  [key: string]: Array<any>;
}

export type OpenReferralRefereeDetail = {
  refereeAddress: string;
  tradeAndEarnPoints: string;
  refereePoints: string;
  rewardedPoints: string; // as a referrer,
  lastTraded: string;
  dateJoined: string;
};

export type OpenReferralRefereeDetails = OpenReferralRefereeDetail[];

export type OpenReferralDetails = {
  referralCode: string;
  referralCount: number;
};

export interface BatchClaimPayload {
  vaultName: string;
  payload: SignaturePayload;
  signature: string;
  coinDecimals?: number;
}
// firefly Library
export * from "@firefly-exchange/library-sui";
// interfaces
export * from "./src/interfaces/routes";
export * from "./src/interfaces/index";

// api
export * from "./src/exchange/apiService";
export * from "./src/exchange/apiUrls";

// firefly client
export * from "./src/bluefinClient";

// constants
export * from "./src/constants";
/**
 * Places the order cancellation request to exchange
 */

/* eslint-disable no-console */

import {
  ORDER_SIDE,
  ORDER_TYPE,
  BluefinClient,
  Networks,
} from "@bluefin-exchange/bluefin-v2-client";

async function main() {
  const dummyAccountKey =
    "trigger swim reunion gate hen black real deer light nature trial dust";

  const client = new BluefinClient(
    true,
    Networks.TESTNET_SUI,
    dummyAccountKey,
    "ED25519" //valid values are ED25519 or Secp256k1
  ); //passing isTermAccepted = true for compliance and authorizarion
  await client.init();

  let symbol = "ETH-PERP";
  // post a limit order
  const response = await client.postOrder({
    symbol: symbol,
    price: 50,
    quantity: 0.5,
    side: ORDER_SIDE.SELL,
    orderType: ORDER_TYPE.LIMIT,
    leverage: 3,
  });

  // create signature
  const cancelSignature = await client.createOrderCancellationSignature({
    symbol: symbol,
    hashes: [response.response.data.hash],
  });

  // place order for cancellation on exchange
  const cancellationResponse = await client.placeCancelOrder({
    symbol: symbol,
    hashes: [response.response.data.hash],
    signature: cancelSignature,
  });

  console.log(cancellationResponse.data);
}

main().then().catch(console.warn);
/**
 * Getting user's USDC balance locked in Margin Bank
 */
import { BluefinClient, Networks } from "@bluefin-exchange/bluefin-v2-client";

async function main() {
  const dummyAccountKey =
    "royal reopen journey royal enlist vote core cluster shield slush hill sample";
  // using TESTNET network
  const client = new BluefinClient(
    true,
    Networks.TESTNET_SUI,
    dummyAccountKey,
    "ED25519" //valid values are ED25519 or Secp256k1
  ); //passing isTermAccepted = true for compliance and authorizarion
  await client.init();

  // will use margin bank contract from contractAddresses (initialized above)
  console.log(
    "User's locked USDC in margin bank are: ",
    await client.getMarginBankBalance()
  );
}

main().then().catch(console.warn);
/**
 * Client initialization code example
 */

/* eslint-disable no-console */
import { BluefinClient, Networks } from "@bluefin-exchange/bluefin-v2-client";

async function main() {
  const dummyAccountKey =
    "royal reopen journey royal enlist vote core cluster shield slush hill sample";

  const client = new BluefinClient(
    true,
    Networks.TESTNET_SUI, // i.e. TESTNET_SUI or PRODUCTION_SUI
    dummyAccountKey,
    "ED25519" // valid values are ED25519 or Secp256k1
  ); //passing isTermAccepted = true for compliance and authorizarion

  // load/init contract addresses
  await client.init();

  //receive read-only token in response
  const resp = await client.generateReadOnlyToken();

  console.log(resp.data);
}

main().then().catch(console.warn);
/**
 * Client initialization code example
 */
import {
  BluefinClient,
  Networks,
  MinifiedCandleStick,
} from "@bluefin-exchange/bluefin-v2-client";

async function main() {
  const dummyAccountKey =
    "royal reopen journey royal enlist vote core cluster shield slush hill sample";

  // using predefined network
  const client = new BluefinClient(
    true,
    Networks.TESTNET_SUI,
    dummyAccountKey,
    "ED25519"
  ); //passing isTermAccepted = true for compliance and authorizarion
  await client.init();
  client.sockets.open();
  client.sockets.subscribeGlobalUpdatesBySymbol("ETH-PERP");
  client.sockets.subscribeUserUpdateByToken();

  let callback = (candle: MinifiedCandleStick) => {
    console.log(candle);
    client.sockets.close();
  };
  client.sockets.onCandleStickUpdate("ETH-PERP", "1m", callback);
}

main().then().catch(console.warn);
/**
 * Client initialization code example
 */
import {
  BluefinClient,
  Networks,
  TickerData,
} from "@bluefin-exchange/bluefin-v2-client";

async function main() {
  const dummyAccountKey =
    "royal reopen journey royal enlist vote core cluster shield slush hill sample";

  // using predefined network
  const client = new BluefinClient(
    true,
    Networks.TESTNET_SUI,
    dummyAccountKey,
    "ED25519"
  ); //passing isTermAccepted = true for compliance and authorizarion
  await client.init();
  client.sockets.open();
  client.sockets.subscribeGlobalUpdatesBySymbol("ETH-PERP");
  client.sockets.subscribeUserUpdateByToken();

  const callback = (tickerUpdate: TickerData[]) => {
    console.log(tickerUpdate);
    client.sockets.close();
  };

  client.sockets.onTickerUpdate(callback);
}

main().then().catch(console.warn);
/**
 * Client initialization code example
 */
import {
  BluefinClient,
  Networks,
  ORDER_SIDE,
  ORDER_TYPE,
} from "@bluefin-exchange/bluefin-v2-client";

async function main() {
  const dummyAccountKey =
    "royal reopen journey royal enlist vote core cluster shield slush hill sample";

  // using predefined network
  const client = new BluefinClient(
    true,
    Networks.TESTNET_SUI,
    dummyAccountKey,
    "ED25519"
  ); //passing isTermAccepted = true for compliance and authorizarion
  await client.init();
  let callback = ({ orderbook }: any) => {
    console.log(orderbook);
    client.sockets.close();
  };

  const connection_callback = async () => {
    // This callback will be invoked as soon as the socket connection is established
    // start listening to local user events
    client.sockets.subscribeGlobalUpdatesBySymbol("BTC-PERP");
    client.sockets.subscribeUserUpdateByToken();

    // triggered when order updates are received
    client.sockets.onOrderBookUpdate(callback);
  };

  const disconnection_callback = async () => {
    console.log("Sockets disconnected, performing actions...");
  };

  // must specify connection_callback before opening the sockets below
  await client.sockets.listen("connect", connection_callback);
  await client.sockets.listen("disconnect", disconnection_callback);

  console.log("Making socket connection to firefly exchange");
  client.sockets.open();

  // wait for 1 sec as room might not had been subscribed

  client.postOrder({
    symbol: "ETH-PERP",
    price: 233,
    quantity: 0.1,
    side: ORDER_SIDE.SELL,
    leverage: 3,
    orderType: ORDER_TYPE.LIMIT,
  });
}

main().then().catch(console.warn);
export const TEST_ACCT_KEY =
  "cigar tip purchase gym income crumble short hobby model rocket push twelve"; // public key 0x6579b6b4edd3d89ba088ea9d4fcdc3d9e030605054ebff2def870e601bc3eb98
export const TEST_SUB_ACCT_KEY =
  "7540d48032c731b3a17947b63a04763492d84aef854246d355a703adc9b54ce9";
export const TEST_NETWORK = "SUI_STAGING";
/**
 * Posts an order to exchange. Creates the signed order and places it to exchange,
 * without requiring two separate function calls.
 */

/* eslint-disable no-console */
import {
  ORDER_SIDE,
  ORDER_TYPE,
  BluefinClient,
  Networks,
} from "@bluefin-exchange/bluefin-v2-client";

async function main() {
  const dummyAccountKey =
    "trigger swim reunion gate hen black real deer light nature trial dust";

  const client = new BluefinClient(
    true,
    Networks.TESTNET_SUI,
    dummyAccountKey,
    "ED25519" //valid values are ED25519 or Secp256k1
  ); //passing isTermAccepted = true for compliance and authorizarion
  await client.init();
  let symbol = "ETH-PERP";

  // will post a limit order of 0.5 quantity at price 11
  const response = await client.postOrder({
    symbol: symbol,
    price: 50,
    quantity: 0.5,
    side: ORDER_SIDE.BUY,
    orderType: ORDER_TYPE.LIMIT,
    leverage: 3,
  });

  console.log(response.data);
}

main().then().catch(console.error);
/**
 * Post an order on exchange and then cancel the posted order
 */

/* eslint-disable no-console */

import {
  ORDER_SIDE,
  ORDER_TYPE,
  BluefinClient,
  Networks,
} from "@bluefin-exchange/bluefin-v2-client";

async function main() {
  const dummyAccountKey =
    "trigger swim reunion gate hen black real deer light nature trial dust";

  const client = new BluefinClient(
    true,
    Networks.TESTNET_SUI,
    dummyAccountKey,
    "ED25519"
  ); //passing isTermAccepted = true for compliance and authorizarion
  await client.init();

  // post a limit order
  let symbol = "ETH-PERP";
  const response = await client.postOrder({
    symbol: symbol,
    price: 51,
    quantity: 0.5,
    side: ORDER_SIDE.SELL,
    orderType: ORDER_TYPE.LIMIT,
    leverage: 3,
  });

  // posts order for cancellation on exchange
  const cancellationResponse = await client.postCancelOrder({
    symbol: symbol,
    hashes: [response.response.data.hash],
  });

  console.log(cancellationResponse.data);
}

main().then().catch(console.warn);
/**
 * Create an order signature on chain and returns it. The signature is used to verify
 * during on-chain trade settlement whether the orders being settled against each other
 * were actually signed on by the maker/taker of the order or not.
 */

/* eslint-disable no-console */

import {
  ORDER_SIDE,
  ORDER_TYPE,
  BluefinClient,
  Networks,
} from "@bluefin-exchange/bluefin-v2-client";

async function main() {
  // no gas fee is required to create order signature.
  const dummyAccountKey =
    "trigger swim reunion gate hen black real deer light nature trial dust";

  const client = new BluefinClient(
    true,
    Networks.TESTNET_SUI,
    dummyAccountKey,
    "ED25519" //valid values are ED25519 or Secp256k1
  ); // passing isTermAccepted = true for compliance and authorization
  await client.init();
  let symbol = "ETH-PERP";

  try {
    client.createSignedOrder({
      symbol: symbol,
      price: 0,
      quantity: 0.1,
      side: ORDER_SIDE.SELL,
      orderType: ORDER_TYPE.MARKET,
    });
  } catch (e) {
    console.log("Error:", e);
  }

  // will create a signed order to sell 0.1 DOT at MARKET price
  const signedOrder = await client.createSignedOrder({
    symbol: symbol, // asset to be traded
    price: 0, // 0 implies market order
    quantity: 0.1, // the amount of asset to trade
    side: ORDER_SIDE.SELL, // buy or sell
    orderType: ORDER_TYPE.MARKET,
  });

  console.log("Signed Order Created:", signedOrder);
}

main().then().catch(console.warn);
/**
 * Cancels all open orders for the given market
 */

/* eslint-disable no-console */

import {
  ORDER_SIDE,
  ORDER_TYPE,
  BluefinClient,
  Networks,
} from "@bluefin-exchange/bluefin-v2-client";

async function main() {
  const dummyAccountKey =
    "trigger swim reunion gate hen black real deer light nature trial dust";

  const client = new BluefinClient(
    true,
    Networks.TESTNET_SUI,
    dummyAccountKey,
    "ED25519" //valid for ED25519 and Secp246k1
  ); //passing isTermAccepted = true for compliance and authorizarion
  await client.init();
  let symbol = "ETH-PERP";
  // open multiple limit orders
  const res1 = await client.postOrder({
    symbol: symbol,
    price: 50,
    quantity: 0.5,
    side: ORDER_SIDE.SELL,
    orderType: ORDER_TYPE.LIMIT,
    leverage: 3,
  });

  console.log(res1);

  const res2 = await client.postOrder({
    symbol: symbol,
    price: 50,
    quantity: 0.5,
    side: ORDER_SIDE.SELL,
    orderType: ORDER_TYPE.LIMIT,
    leverage: 3,
  });

  console.log(res2);

  // cancels all open order
  const response = await client.cancelAllOpenOrders(symbol);

  console.log(response.data);
}

main().then().catch(console.warn);
/**
 * Gets user open position on provided(all) markets
 */

/* eslint-disable no-console */

import {
  BluefinClient,
  Networks,
  ADJUST_MARGIN,
} from "@bluefin-exchange/bluefin-v2-client";

async function main() {
  const dummyAccountKey =
    "trigger swim reunion gate hen black real deer light nature trial dust";

  const client = new BluefinClient(
    true,
    Networks.TESTNET_SUI,
    dummyAccountKey,
    "ED25519" //valid values are ED25519 or Secp256k1
  ); //passing isTermAccepted = true for compliance and authorizarion
  await client.init();
  // ADD margin - will add 10 margin to ETH-PERP position
  // Please ensure that you have a position open before this. otherwise it wont work.
  console.log(
    "Added margin: ",
    await client.adjustMargin("ETH-PERP", ADJUST_MARGIN.Add, 10)
  );

  // REMOVE MARGIN - will remove 10 margin from ETH-PERP position
  console.log(
    "Removed margin: ",
    await client.adjustMargin("ETH-PERP", ADJUST_MARGIN.Remove, 10)
  );
}

main().then().catch(console.warn);
/**
 * Deposits USDC from USDC contract to MarginBank
 */
import { BluefinClient, Networks } from "@bluefin-exchange/bluefin-v2-client";

async function main() {
  // ensure that account has enough native gas tokens to perform on-chain contract call
  const dummyAccountKey =
    "trigger swim reunion gate hen black real deer light nature trial dust";

  // using TESTNET network, getUSDCBalance does not work on MAINNET
  const client = new BluefinClient(
    true,
    Networks.TESTNET_SUI,
    dummyAccountKey,
    "ED25519" //valid values are ED25519 or Secp256k1
  ); //passing isTermAccepted = true for compliance and authorizarion
  await client.init();
  console.log(await client.getPublicAddress());

  // deposits 10 USDC to margin bank, uses default USDC/MarginBank Contracts
  // assuming user has 1 USDC locked in margin bank, else will throw
  console.log(
    "USDC Deposited to MarginBank: ",
    await client.depositToMarginBank(10)
  );
  console.log(
    "USDC Withdrawn from MarginBank: ",
    await client.withdrawFromMarginBank(1)
  );
  console.log("Current balance", await client.getUSDCBalance());
}

main().then().catch(console.warn);
/**
 * Client initialization code example
 */

/* eslint-disable no-console */
import { BluefinClient, Networks } from "@bluefin-exchange/bluefin-v2-client";

async function main() {
  const dummyAccountKey =
    "royal reopen journey royal enlist vote core cluster shield slush hill sample";

  const client = new BluefinClient(
    true,
    Networks.TESTNET_SUI // i.e. TESTNET_SUI or PRODUCTION_SUI
  ); //passing isTermAccepted = true for compliance and authorizarion

  // load/init contract addresses using read-only token
  await client.init(
    false,
    null,
    "52b5c5d010f5de84880d4b5bfcd9f79513bfa93ae367d884412cedb57c0c2a97"
  );

  //receive user positions using readonly client
  const response = await client.getUserPosition({ symbol: "ETH-PERP" });

  console.log(response.data);
}

main().then().catch(console.warn);
/**
 * Client initialization code example
 */

/* eslint-disable no-console */

import {
  BluefinClient,
  ExtendedNetwork,
  Networks,
} from "@bluefin-exchange/bluefin-v2-client";

async function main() {
  const dummyAccountKey =
    "royal reopen journey royal enlist vote core cluster shield slush hill sample";

  // using seed phrase
  const client = new BluefinClient(
    true,
    Networks.TESTNET_SUI,
    dummyAccountKey,
    "ED25519" //valid values are ED25519 or Secp256k1
  ); //passing isTermAccepted = true for compliance and authorizarion
  await client.init();
  // prints client address
  console.log(client.getPublicAddress());

  // using custom network
  const custNetwork: ExtendedNetwork = {
    name: "testnet",
    url: "https://fullnode.testnet.sui.io:443",
    apiGateway: "https://dapi.api.sui-staging.bluefin.io",
    dmsURL: "https://dapi.api.sui-staging.bluefin.io/dead-man-switch",
    socketURL: "wss://dapi.api.sui-staging.bluefin.io",
    webSocketURL: "wss://notifications.api.sui-staging.bluefin.io",
    onboardingUrl: "https://testnet.bluefin.io",
    faucet: "https://faucet.devnet.sui.io",
  };
  const clientCustomNetwork = new BluefinClient(
    true,
    custNetwork,
    dummyAccountKey,
    "ED25519"
  ); //passing isTermAccepted = true for compliance and authorizarion
  await clientCustomNetwork.init();
  // prints client address
  console.log(clientCustomNetwork.getPublicAddress());

  //Initialise using readonly token
  // using predefined network
  const client_readme = new BluefinClient(
    false,
    Networks.TESTNET_SUI,
    dummyAccountKey,
    "ED25519" //valid values are ED25519 or Secp256k1
  ); // passing isTermAccepted = true for compliance and authorizarion
  await client_readme.init(
    false,
    "9737fb68940ae27f95d5a603792d4988a9fdcf3efeea7185b43f2bd045ee87f9"
  ); // initialze client via readOnlyToken

  //Initialise using private key
  const pvt_key_client = new BluefinClient(
    false,
    Networks.TESTNET_SUI,
    "0xf443768edf901263a0756cc442b9ed0d246ab31deb7f6d05c4d603b1f3fc6206",
    "ED25519" //valid values are ED25519 or Secp256k1
  ); // passing isTermAccepted = true for compliance and authorizarion
  await pvt_key_client.init();
}

main().then().catch(console.warn);
import { Networks, BluefinClient } from "@bluefin-exchange/bluefin-v2-client";
import { TEST_ACCT_KEY, TEST_SUB_ACCT_KEY } from "./config";

async function main() {
  // account keys
  const parentAccountKey = "" || TEST_ACCT_KEY;
  const childAccountKey = "" || TEST_SUB_ACCT_KEY;

  // initialize the parent account client
  const clientParent = new BluefinClient(
    true,
    Networks.TESTNET_SUI,
    parentAccountKey,
    "ED25519"
  );
  await clientParent.init();

  // initialize the child account client
  const clientChild = new BluefinClient(
    true,
    Networks.TESTNET_SUI,
    childAccountKey,
    "ED25519"
  );
  await clientChild.init();

  // Add child account as subaccount
  const resp1 = await clientParent.setSubAccount(
    clientChild.getPublicAddress(),
    true
  );

  console.log(resp1);

  // Remove child account as subaccount
  const resp2 = await clientParent.setSubAccount(
    clientChild.getPublicAddress(),
    false
  );

  console.log(resp2);
}

main().then().catch(console.warn);
/**
 *  Query user orders
 **/
import {
  BluefinClient,
  Networks,
  ORDER_STATUS,
} from "@bluefin-exchange/bluefin-v2-client";

async function main() {
  const dummyAccountKey =
    "trigger swim reunion gate hen black real deer light nature trial dust";

  const client = new BluefinClient(
    true,
    Networks.TESTNET_SUI,
    dummyAccountKey,
    "ED25519" //valid values are ED25519 or Secp256k1
  ); //passing isTermAccepted = true for compliance and authorizarion
  await client.init();

  console.log(
    await client.getUserOrders({ statuses: [ORDER_STATUS.CANCELLED] })
  );
}

main().then().catch(console.warn);
/**
 * Gets user open position on provided(all) markets
 */
import { BluefinClient, Networks } from "@bluefin-exchange/bluefin-v2-client";

async function main() {
  const dummyAccountKey =
    "trigger swim reunion gate hen black real deer light nature trial dust";

  const client = new BluefinClient(
    true,
    Networks.TESTNET_SUI,
    dummyAccountKey,
    "ED25519" //valid values are ED25519 or Secp256k1
  ); //passing isTermAccepted = true for compliance and authorizarion
  await client.init();

  const response = await client.getUserPosition({ symbol: "ETH-PERP" });

  console.log(response.data);
}

main().then().catch(console.warn);
/* eslint-disable prettier/prettier */
/* eslint-disable no-undef */
import chai, { expect } from "chai";
import chaiAsPromised from "chai-as-promised";

import {
  BASE_DECIMALS,
  ORDER_SIDE,
  ORDER_TYPE,
  OnChainCalls,
  TIME_IN_FORCE,
  Transaction,
  USDC_BASE_DECIMALS,
  toBigNumberStr,
  getSignerFromSeed,
  readFile,
  SuiClient,
} from "@firefly-exchange/library-sui";
import { BluefinClient, Networks, OrderSignatureResponse } from "../index";
import { setupTestAccounts } from "../utils/utils";

chai.use(chaiAsPromised);

// please update deployer if contracts are redeployed
const deployer = {
  phrase:
    "explain august dream guitar mail attend enough demise engine pulse wide later",
  privateAddress:
    "0x958fb79396a09247d6c05aa9bcd51a94f6233c1399ec15e07a07ff4b77e5578c",
};

const TEST_WALLETS = [
  {
    phrase:
      "weasel knee fault hammer gift joke ability tilt brass about ladder ramp",
    privateAddress:
      "0x551db36b08c694b8382fab5cec41641a07fbe6e8b36dfdb1d6376a8f39d9e1dc",
  },
  {
    phrase:
      "blouse swim window brother elephant winner act pencil visa acoustic try west",
    privateAddress:
      "0xae718f76f26af59a9b33913be566627fa598ca80891a417d6a94e72bd5c24e6f",
  },
];

describe("BluefinClient", () => {
  //* set environment from here
  let deplymentJson: any;
  const network = Networks.TESTNET_SUI;
  const symbol = "BTC-PERP";
  const defaultLeverage = 1;
  let client: BluefinClient;
  let onChainCalls: OnChainCalls;
  before(async () => {
    client = new BluefinClient(
      true,
      network,
      TEST_WALLETS[0].phrase,
      "Secp256k1"
    );
    await client.init();
    deplymentJson = await readFile(
      "/home/radheem/github/bluefin-v2-client/deployment.json"
    );
    expect(deplymentJson).to.be.not.eq(undefined);
    const signer = getSignerFromSeed(deployer.phrase);
    const suiClient = new SuiClient({ url: network.url });
    onChainCalls = new OnChainCalls(signer, deplymentJson, suiClient);
    await setupTestAccounts(onChainCalls, TEST_WALLETS, network.faucet);
  });

  beforeEach(async () => {
    client = new BluefinClient(
      true,
      network,
      TEST_WALLETS[0].phrase,
      "Secp256k1"
    );
    await client.init();
  });

  afterEach(() => {
    client.sockets.close();
  });

  it("should initialize the client", async () => {
    expect(client).to.be.not.eq(undefined);
  });

  it("should return public address of account", async () => {
    expect(client.getPublicAddress()).to.be.equal(
      TEST_WALLETS[0].privateAddress
    );
  });

  describe("Balance", () => {
    it("should get 10K Test USDCs", async () => {
      const usdcBalance = await client.getUSDCBalance();
      const mintAmount = 10000;
      const tx = await onChainCalls.mintUSDC({
        amount: toBigNumberStr(mintAmount, BASE_DECIMALS),
        to: client.getPublicAddress(),
      });
      expect(Transaction.getStatus(tx)).to.be.equal("success");
      const expectedBalance =
        Math.round((usdcBalance + mintAmount) * 100) / 100;
      const newBalance =
        Math.round((await client.getUSDCBalance()) * 100) / 100;
      expect(newBalance).to.be.gte(expectedBalance);
    });

    it("should move 1 USDC token to Margin Bank", async () => {
      const usdcBalance = await client.getUSDCBalance();
      const marginBankBalance = await client.getMarginBankBalance();
      const depositAmount = 1;
      expect((await client.depositToMarginBank(depositAmount))?.ok).to.be.equal(
        true
      );
      const newBalance =
        Math.round((await client.getUSDCBalance()) * 100) / 100;
      const expectedBalance =
        Math.round((usdcBalance - depositAmount) * 100) / 100;
      expect(newBalance).to.be.lte(expectedBalance);
      const newMarginBankBalance =
        Math.round((await client.getMarginBankBalance()) * 100) / 100;
      const expectedMarginBankBalance =
        Math.round((marginBankBalance + depositAmount) * 100) / 100;
      expect(newMarginBankBalance).to.be.gte(expectedMarginBankBalance);
    });

    it("should withdraw 1 USDC token from Margin Bank", async () => {
      const usdcBalance = await client.getUSDCBalance();
      expect((await client.withdrawFromMarginBank(1))?.ok).to.be.equal(true);
      expect(await client.getUSDCBalance()).to.be.gte(usdcBalance + 1);
    });

    it("should move all USDC token from Margin Bank", async () => {
      expect((await client.withdrawFromMarginBank())?.ok).to.be.equal(true);
      expect(await client.getMarginBankBalance()).to.be.eql(0);
    });
  });

  describe("Create Orders", () => {
    beforeEach(async () => {});

    it("should create signed order", async () => {
      const signedOrder = await client.createSignedOrder({
        symbol,
        price: 0,
        quantity: 0.1,
        side: ORDER_SIDE.SELL,
        orderType: ORDER_TYPE.MARKET,
      });
      expect(signedOrder.leverage).to.be.equal(defaultLeverage);
      expect(signedOrder.price).to.be.equal(0);
      expect(signedOrder.quantity).to.be.equal(0.1);
    });
  });

  describe("Trade", () => {
    let maker: BluefinClient;
    let taker: BluefinClient;
    let signedMakerOrder: OrderSignatureResponse;
    let signedTakerOrder: OrderSignatureResponse;
    const tradePrice = 1800;
    const tradeQty = 0.1;
    const depositAmount = tradePrice * tradeQty;
    before(async () => {
      maker = new BluefinClient(
        true,
        Networks.TESTNET_SUI,
        TEST_WALLETS[0].phrase,
        "Secp256k1"
      );
      await maker.init();
      taker = new BluefinClient(
        true,
        Networks.TESTNET_SUI,
        TEST_WALLETS[1].phrase,
        "Secp256k1"
      );
      await taker.init();
      await setupTestAccounts(
        onChainCalls,
        TEST_WALLETS,
        Networks.TESTNET_SUI.faucet
      );
      let tx = await onChainCalls.mintUSDC({
        amount: toBigNumberStr(10000, USDC_BASE_DECIMALS),
        to: maker.getPublicAddress(),
      });
      expect(Transaction.getStatus(tx)).to.be.equal("success");
      tx = await onChainCalls.mintUSDC({
        amount: toBigNumberStr(10000, USDC_BASE_DECIMALS),
        to: taker.getPublicAddress(),
      });
      expect(Transaction.getStatus(tx)).to.be.equal("success");
    });

    beforeEach(async () => {});

    afterEach(() => {});

    it("should have required USDCs", async () => {
      const balance = await maker.getUSDCBalance();
      expect(balance).to.be.gte(depositAmount);
      const balance2 = await taker.getUSDCBalance();
      expect(balance2).to.be.gte(depositAmount);
    });

    it("should move required USDC token to Margin Bank", async () => {
      const balance = await maker.getMarginBankBalance();
      const resp = await maker.depositToMarginBank(depositAmount);
      expect(resp.ok).to.be.equal(true);
      expect(await maker.getMarginBankBalance()).to.be.gte(
        balance + depositAmount
      );
      const balance1 = await taker.getMarginBankBalance();
      const resp1 = await taker.depositToMarginBank(depositAmount);
      expect(resp1.ok).to.be.equal(true);
      expect(await taker.getMarginBankBalance()).to.be.gte(
        balance1 + depositAmount
      );
    });

    it("should create signed maker order", async () => {
      signedMakerOrder = await maker.createSignedOrder({
        symbol,
        price: tradePrice,
        quantity: tradeQty,
        side: ORDER_SIDE.SELL,
        orderType: ORDER_TYPE.LIMIT,
        timeInForce: TIME_IN_FORCE.GOOD_TILL_TIME,
      });

      expect(signedMakerOrder.leverage).to.be.equal(defaultLeverage);
      expect(signedMakerOrder.price).to.be.equal(tradePrice);
      expect(signedMakerOrder.quantity).to.be.equal(tradeQty);
    });

    it("should create signed taker order", async () => {
      signedTakerOrder = await taker.createSignedOrder({
        symbol,
        price: tradePrice,
        quantity: tradeQty,
        side: ORDER_SIDE.BUY,
        orderType: ORDER_TYPE.MARKET,
        timeInForce: TIME_IN_FORCE.IMMEDIATE_OR_CANCEL,
      });

      expect(signedTakerOrder.leverage).to.be.equal(defaultLeverage);
      expect(signedTakerOrder.price).to.be.equal(tradePrice);
      expect(signedTakerOrder.quantity).to.be.equal(tradeQty);
    });

    // it("should perform trade", async () => {
    //   const [success, tx] = await performTrade(
    //     onChainCalls,
    //     getSignerFromSeed(deployer.phrase, maker.getProvider()),
    //     signedMakerOrder,
    //     signedTakerOrder,
    //     tradePrice
    //   );
    //   if (!success) {
    //     console.log(
    //       "\n#################################################################\nTransaction: ",
    //       tx,
    //       "\n#################################################################"
    //     );
    //   }
    //   expect(success).to.be.equal(true);
    // });
  });

  describe("Sub account Tests", () => {
    let clientSubAccount: BluefinClient;
    before(async () => {
      clientSubAccount = new BluefinClient(
        true,
        network,
        TEST_WALLETS[0].phrase,
        "Secp256k1"
      );
      await clientSubAccount.init();

      // adding sub acc
      const resp = await client.setSubAccount(
        TEST_WALLETS[1].privateAddress,
        true
      );
      if (!resp.ok) {
        throw Error(resp.message);
      }
    });
    beforeEach(async () => {
      clientSubAccount = new BluefinClient(
        true,
        network,
        TEST_WALLETS[0].phrase,
        "Secp256k1"
      );
      await clientSubAccount.init();
    });
    // TODO: Uncomment once DAPI is up
    // it("get leverage on behalf of parent account", async () => {
    //   const res = await clientSubAccount.getUserDefaultLeverage(
    //     symbol,
    //     TEST_WALLETS[0].privateAddress.toLowerCase()
    //   ); // set leverage will do contract call as the account using is new
    //   // Then
    //   console.log("res", res);
    //   expect(res).to.eq(defaultLeverage);
    // });

    it("set leverage on behalf of parent account", async () => {
      // The user needs to have an open position to set leverage
      // When
      const newLeverage = 2;
      const res = await clientSubAccount.adjustLeverage({
        symbol,
        leverage: newLeverage,
        parentAddress: TEST_WALLETS[0].privateAddress.toLowerCase(),
      }); // set leverage will do contract call as the account using is new
      // Then
      if (!res.ok) {
        throw Error(res.message);
      }
      expect(res.ok).to.eq(true);
    });
  });
});
/* eslint-disable prettier/prettier */
/* eslint-disable no-undef */
import chai, { expect } from "chai";
import chaiAsPromised from "chai-as-promised";
import { setTimeout } from "timers/promises";

import {
  Faucet,
  MinifiedCandleStick,
  OrderSigner,
  ORDER_SIDE,
  ORDER_STATUS,
  // MinifiedCandleStick,
  ORDER_TYPE,
  parseSigPK,
  toBaseNumber,
} from "@firefly-exchange/library-sui";
import {
  BluefinClient,
  GetAccountDataResponse,
  GetMarketRecentTradesResponse,
  GetPositionResponse,
  GetUserTradesResponse,
  Networks,
  OffchainOrderUpdateAction,
  OrderSentForSettlementUpdateResponse,
  PlaceOrderResponse,
  TickerData,
} from "../index";
import { generateRandomNumber } from "../utils/utils";

chai.use(chaiAsPromised);

const testAcctKey =
  "person essence firm tail chapter forest return pulse dismiss unlock zebra amateur";
const testAcctPubAddr =
  "0x803da161f88726c43f1e17b230257d91eca0b84d851a4493b8341d7267e4dbc6";

const testSubAccKey =
  "inherit save afford act peanut retire fluid stool setup reject shallow already";
const testSubAccPubAddr =
  "0x7c550b81ce7f8f458f5520d55623eb5dd1013310323607c0c7b5c3625e47079e";

Faucet.requestSUI(testAcctPubAddr, Networks.TESTNET_SUI.faucet);
Faucet.requestSUI(testSubAccPubAddr, Networks.TESTNET_SUI.faucet);

//* set environment from here
const network = Networks.TESTNET_SUI;

let client: BluefinClient;

describe("BluefinClient", () => {
  let symbol = "ETH-PERP";
  let defaultLeverage = 3;
  let buyPrice = 1600;
  let sellPrice = 2000;
  let marketPrice = 0;
  let indexPrice = 1600;

  before(async () => {
    client = new BluefinClient(true, network, testAcctKey, "ED25519");
    await client.init();
    const allSymbols = await client.getMarketSymbols();
    //get first symbol to run tests on
    if (allSymbols.data) {
      symbol = allSymbols.data[0];
    }

    console.log(`--- Trading symbol: ${symbol} ---`);

    // get default leverage
    // defaultLeverage = await client.getUserDefaultLeverage(symbol);
    defaultLeverage = 3;
    console.log(`- on leverage: ${defaultLeverage}`);

    // market data
    const marketData = await client.getMarketData(symbol);
    if (marketData.data && toBaseNumber(marketData.data.marketPrice) > 0) {
      marketPrice = toBaseNumber(marketData.data.marketPrice);
      indexPrice = toBaseNumber(marketData.data.indexPrice);
      const percentChange = 3 / 100; // 3%
      buyPrice = Number((marketPrice - marketPrice * percentChange).toFixed(0));
      sellPrice = Number(
        (marketPrice + marketPrice * percentChange).toFixed(0)
      );
      console.log(`- market price: ${marketPrice}`);
      console.log(`- index price: ${indexPrice}`);
    }
  });

  beforeEach(async () => {
    client = new BluefinClient(true, network, testAcctKey, "ED25519");
    await client.init();
  });

  afterEach(() => {
    client.sockets.close();
  });

  it("should initialize the client", async () => {
    expect(client).to.be.not.eq(undefined);
  });

  it("should return public address of account", async () => {
    expect(client.getPublicAddress()).to.be.equal(testAcctPubAddr);
  });

  describe("Sub account Tests", () => {
    let clientSubAccount: BluefinClient;
    before(async () => {
      clientSubAccount = new BluefinClient(
        true,
        network,
        testAcctKey,
        "Secp256k1"
      );
      await clientSubAccount.init();

      // adding sub acc
      const resp = await client.setSubAccount(
        testSubAccPubAddr.toLowerCase(),
        true
      );
      if (!resp.ok) {
        throw Error(resp.message);
      }
    });
    beforeEach(async () => {
      clientSubAccount = new BluefinClient(
        true,
        network,
        testAcctKey,
        "Secp256k1"
      );
      await clientSubAccount.init();
    });

    it("set and get leverage on behalf of parent account", async () => {
      // make sure to first whitelist the subaccount with the below parent account to run this test.
      // To whitelist the subaccount use the above test {set sub account}
      // and subaccount must be authenticated/initialized with the client.
      // When
      const newLeverage = 5;
      const res = await clientSubAccount.adjustLeverage({
        symbol,
        leverage: newLeverage,
        parentAddress: testAcctPubAddr.toLowerCase(),
      }); // set leverage will do contract call as the account using is new
      const lev = await clientSubAccount.getUserDefaultLeverage(
        symbol,
        testAcctPubAddr.toLowerCase()
      ); // get leverage

      // Then
      expect(res.ok).to.eq(true);
      // expect(lev).to.equal(newLeverage);
    });
    it("should place a MARKET BUY order on behalf of parent exchange", async () => {
      // make sure to first whitelist the subaccount with the below parent account to run this test.
      // To whitelist the subaccount use the above test {set sub account}
      // and subaccount must be authenticated/initialized with the client.
      const signedOrder = await clientSubAccount.createSignedOrder({
        symbol,
        price: 0,
        quantity: 0.01,
        side: ORDER_SIDE.BUY,
        leverage: defaultLeverage,
        orderType: ORDER_TYPE.MARKET,
        // parent account
        maker: testAcctPubAddr,
      });
      const response = await clientSubAccount.placeSignedOrder({
        ...signedOrder,
      });
      expect(response.ok).to.be.equal(true);
    });
    it("should cancel the open order on behalf of parent account", async () => {
      // make sure to first whitelist the subaccount with the below parent account to run this test.
      // To whitelist the subaccount use the above test {set sub account}
      // and subaccount must be authenticated/initialized with the client.
      const signedOrder = await clientSubAccount.createSignedOrder({
        symbol,
        price: sellPrice,
        quantity: 0.01,
        side: ORDER_SIDE.SELL,
        leverage: defaultLeverage,
        orderType: ORDER_TYPE.LIMIT,
        maker: testAcctPubAddr,
      });
      const response = await clientSubAccount.placeSignedOrder({
        ...signedOrder,
        clientId: "test cancel order",
      });
      const cancelSignature =
        await clientSubAccount.createOrderCancellationSignature({
          symbol,
          hashes: [response.response.data.hash],
          parentAddress: testAcctPubAddr.toLowerCase(),
        });

      const cancellationResponse = await clientSubAccount.placeCancelOrder({
        symbol,
        hashes: [response.response.data.hash],
        signature: cancelSignature,
        parentAddress: testAcctPubAddr.toLowerCase(),
      });

      expect(cancellationResponse.ok).to.be.equal(true);
    });
    it("should get all open orders on behalf of parent account", async () => {
      // make sure to first whitelist the subaccount with the below parent account to run this test.
      // To whitelist the subaccount use the above test {set sub account}
      // and subaccount must be authenticated/initialized with the client.
      const data = await clientSubAccount.getUserOrders({
        statuses: [ORDER_STATUS.OPEN],
        symbol,
        parentAddress: testAcctPubAddr.toLowerCase(),
      });
      expect(data.ok).to.be.equals(true);
      expect(data.response.data.length).to.be.gte(0);
    });
    it("should get user's Position on behalf of parent account", async () => {
      // make sure to first whitelist the subaccount with the below parent account to run this test.
      // To whitelist the subaccount use the above test {set sub account}
      // and subaccount must be authenticated/initialized with the client.
      const response = await clientSubAccount.getUserPosition({
        symbol,
        parentAddress: testAcctPubAddr.toLowerCase(),
      });

      const position = response.data as any as GetPositionResponse;
      if (Object.keys(position).length > 0) {
        expect(response.response.data.symbol).to.be.equal(symbol);
      }
    });
    it("should get user's Trades on behalf of parent account", async () => {
      // make sure to first whitelist the subaccount with the below parent account to run this test.
      // To whitelist the subaccount use the above test {set sub account}
      // and subaccount must be authenticated/initialized with the client.
      const response = await clientSubAccount.getUserTrades({
        symbol,
        parentAddress: testAcctPubAddr,
      });
      expect(response.ok).to.be.equal(true);
    });

    it("should get user's Trades history on behalf of parent account", async () => {
      // make sure to first whitelist the subaccount with the below parent account to run this test.
      // To whitelist the subaccount use the above test {set sub account}
      // and subaccount must be authenticated/initialized with the client.
      const response = await clientSubAccount.getUserTradesHistory({
        symbol,
        parentAddress: testAcctPubAddr,
      });
      expect(response.ok).to.be.equal(true);
    });

    it("should get User Account Data on behalf of parent account", async () => {
      // make sure to first whitelist the subaccount with the below parent account to run this test.
      // To whitelist the subaccount use the above test {set sub account}
      // and subaccount must be authenticated/initialized with the client.
      const response = await clientSubAccount.getUserAccountData(
        testAcctPubAddr
      );
      expect(response.ok).to.be.equal(true);
    });
    it("should get Funding History records for user on behalf of parent account", async () => {
      // make sure to first whitelist the subaccount with the below parent account to run this test.
      // To whitelist the subaccount use the above test {set sub account}
      // and subaccount must be authenticated/initialized with the client.
      const response = await clientSubAccount.getUserFundingHistory({
        symbol,
        parentAddress: testAcctPubAddr,
      });
      expect(response.ok).to.be.equal(true);
    });
  });

  it("should whitelist the subaccount for One Click Trading", async () => {
    // whitelisting sub account
    const resp = await client.upsertSubAccount({
      subAccountAddress: testSubAccKey,
    });
    expect(resp.ok).to.be.equal(true);
    expect(resp.data.subAccountAddress).to.be.equal(testSubAccPubAddr);
  });

  // describe("Market", () => {
  //   it(`should add ${symbol} market`, async () => {
  //     expect(client.addMarket(symbol)).to.be.equal(true);
  //   });

  //   it(`should add ${symbol} market with custom orders contract address`, async () => {
  //     expect(
  //       client.addMarket(symbol, "0x36AAc8c385E5FA42F6A7F62Ee91b5C2D813C451C")
  //     ).to.be.equal(true);
  //   });

  //   it("should throw error as there is no market by name of TEST-PERP in deployedContracts", async () => {
  //     assert.throws(
  //       () => {
  //         client.addMarket("TEST-PERP");
  //       },
  //       Error,
  //       `Contract "IsolatedTrader" not found in contract addresses for network id ${network.chainId}`
  //     );
  //   });

  //   it("should add market despite not existing in deployed contracts", async () => {
  //     expect(
  //       client.addMarket(
  //         "TEST-PERP",
  //         "0x36AAc8c385E5FA42F6A7F62Ee91b5C2D813C451C"
  //       )
  //     ).to.be.equal(true);
  //   });

  //   it("should return False as BTC-PERP market is already added", async () => {
  //     expect(client.addMarket(symbol)).to.be.equal(true);
  //     expect(client.addMarket(symbol)).to.be.equal(false);
  //   });

  //   it("should remove the BTC market", async () => {
  //     expect(client.addMarket(symbol)).to.be.equal(true);
  //     expect(client.removeMarket(symbol)).to.be.equal(true);
  //   });

  //   it("should return false when trying to remove a non-existent market", async () => {
  //     expect(client.removeMarket(symbol)).to.be.equal(false);
  //   });
  // });

  // describe("Fund Gas", () => {
  //   it("get gas token balance", async () => {
  //     const response = await client.getChainNativeBalance();
  //     expect(bigNumber(response).gte(bigNumber(0))).to.eq(true);
  //   });
  // });

  describe("Balance", () => {
    it("should get 10K Test USDCs", async () => {
      const usdcBalance = await client.getUSDCBalance();
      expect(await client.mintTestUSDC(10000)).to.be.equal(true);
      expect(await client.getUSDCBalance()).to.be.gte(usdcBalance + 10000);
    });

    it("should move 1 USDC token to Margin Bank", async () => {
      const usdcBalance = await client.getUSDCBalance();
      expect((await client.depositToMarginBank(1))?.ok).to.be.equal(true);
      expect(await client.getMarginBankBalance()).to.be.gte(1);
      expect(await client.getUSDCBalance()).to.be.gte(usdcBalance - 1);
    });

    it("should withdraw 1 USDC token from Margin Bank", async () => {
      const usdcBalance = await client.getUSDCBalance();
      expect((await client.withdrawFromMarginBank(1))?.ok).to.be.equal(true);
      expect(await client.getUSDCBalance()).to.be.gte(usdcBalance + 1);
    });

    it("should move all USDC token from Margin Bank", async () => {
      expect((await client.withdrawFromMarginBank())?.ok).to.be.equal(true);
      expect(await client.getMarginBankBalance()).to.be.eql(0);
    });
  });

  describe("Leverage getter and setter", () => {
    beforeEach(async () => {
      //   client.addMarket(symbol);
    });

    it("set and get leverage", async () => {
      // Given
      const clientTemp = new BluefinClient(true, network);
      await clientTemp.init();
      // When
      const newLeverage = 4;
      const res = await clientTemp.adjustLeverage({
        symbol,
        leverage: newLeverage,
      }); // set leverage will do contract call as the account using is new
      const lev = await clientTemp.getUserDefaultLeverage(symbol); // get leverage
      // Then
      expect(res.ok).to.eq(true);
      expect(lev).to.equal(4);
    });
  });

  describe("Create/Place/Post Orders", () => {
    // it("should put 10K in margin bank", async () => {
    //   const minted = await client.mintTestUSDC();
    //   const coins = await client.getUSDCCoins(10000);
    //   const deposited = await client.depositToMarginBank(10000, coins[0].id);
    //   expect(minted).to.eq(true);
    //   expect(deposited.ok).to.eq(true);
    // });

    // it("should throw error as DOT market is not added to client", async () => {
    //   await expect(
    //     client.createSignedOrder({
    //       symbol: "DOT-TEST",
    //       price: 0,
    //       quantity: 0.1,
    //       side: ORDER_SIDE.SELL,
    //       orderType: ORDER_TYPE.MARKET,
    //     })
    //   ).to.be.eventually.rejectedWith(
    //     "Provided Market Symbol(DOT-TEST) is not added to client library"
    //   );
    // });

    it("should create signed order", async () => {
      const signedOrder = await client.createSignedOrder({
        symbol,
        price: 0,
        quantity: 0.1,
        side: ORDER_SIDE.SELL,
        orderType: ORDER_TYPE.MARKET,
      });

      expect(signedOrder.leverage).to.be.equal(1);
      expect(signedOrder.price).to.be.equal(0);
      expect(signedOrder.quantity).to.be.equal(0.1);
    });

    it("should create signed order and verify the signature", async () => {
      const params = {
        symbol,
        price: 0,
        quantity: 0.1,
        side: ORDER_SIDE.SELL,
        orderType: ORDER_TYPE.MARKET,
        expiration: Date.now() + 3600,
        salt: generateRandomNumber(1_000),
      };
      const signedOrder = await client.createSignedOrder(params);
      const orderPayload = client.createOrderToSign(params);
      const parsedSigPk = parseSigPK(signedOrder.orderSignature);
      const isValid = OrderSigner.verifySignatureUsingOrder(
        orderPayload,
        parsedSigPk.signature,
        parsedSigPk.publicKey
      );

      expect(isValid).to.be.equal(true);
    });

    it("should place a LIMIT SELL order on exchange", async () => {
      const signedOrder = await client.createSignedOrder({
        symbol,
        price: sellPrice,
        quantity: 0.1,
        side: ORDER_SIDE.SELL,
        leverage: defaultLeverage,
        orderType: ORDER_TYPE.LIMIT,
      });

      const response = await client.placeSignedOrder({ ...signedOrder });
      expect(response.ok).to.be.equal(true);
    });

    it("should place a MARKET BUY order on exchange", async () => {
      const signedOrder = await client.createSignedOrder({
        symbol,
        price: 0,
        quantity: 0.1,
        side: ORDER_SIDE.SELL,
        leverage: defaultLeverage,
        orderType: ORDER_TYPE.MARKET,
      });
      const response = await client.placeSignedOrder({ ...signedOrder });
      expect(response.ok).to.be.equal(true);
    });

    it("should post a LIMIT order on exchange", async () => {
      const response = await client.postOrder({
        symbol,
        price: buyPrice,
        quantity: 0.1,
        side: ORDER_SIDE.BUY,
        leverage: defaultLeverage,
        orderType: ORDER_TYPE.LIMIT,
        clientId: "Test limit order",
      });

      expect(response.ok).to.be.equal(true);
    });

    it("should post a BUY STOP LIMIT order on exchange", async () => {
      defaultLeverage = await client.getUserDefaultLeverage(symbol);
      const response = await client.postOrder({
        symbol,
        quantity: 0.1,
        side: ORDER_SIDE.BUY,
        leverage: defaultLeverage,
        orderType: ORDER_TYPE.STOP_LIMIT,
        clientId: "Test stop limit order",
        price: indexPrice + 4,
        triggerPrice: indexPrice + 2,
      });

      expect(response.ok).to.be.equal(true);
    });

    it("should post a SELL STOP LIMIT order on exchange", async () => {
      defaultLeverage = await client.getUserDefaultLeverage(symbol);
      const response = await client.postOrder({
        symbol,
        quantity: 0.1,
        side: ORDER_SIDE.SELL,
        leverage: defaultLeverage,
        orderType: ORDER_TYPE.STOP_LIMIT,
        clientId: "Test stop limit order",
        price: indexPrice - 4,
        triggerPrice: indexPrice - 2,
      });

      expect(response.ok).to.be.equal(true);
    });
  });

  describe("Cancel Orders", () => {
    beforeEach(async () => {
      //   client.addMarket(symbol);
    });
    it("should create more than 15 orders then cancel them all", async () => {
      for (let i = 0; i < 16; i++) {
        const signedOrder = await client.createSignedOrder({
          symbol,
          price: sellPrice,
          quantity: 0.01,
          side: ORDER_SIDE.SELL,
          leverage: defaultLeverage,
          orderType: ORDER_TYPE.LIMIT,
        });
        await client.adjustLeverage({
          symbol: symbol,
          leverage: defaultLeverage,
        });
        const response = await client.placeSignedOrder({
          ...signedOrder,
          clientId: "test cancel order",
        });
      }
      const cancellationResponse = await client.cancelAllOpenOrders(symbol);
      expect(cancellationResponse.ok).to.be.equal(true);
    });

    it("should cancel the open order", async () => {
      const signedOrder = await client.createSignedOrder({
        symbol,
        price: sellPrice,
        quantity: 0.01,
        side: ORDER_SIDE.SELL,
        leverage: defaultLeverage,
        orderType: ORDER_TYPE.LIMIT,
      });
      await client.adjustLeverage({
        symbol: symbol,
        leverage: defaultLeverage,
      });
      const response = await client.placeSignedOrder({
        ...signedOrder,
        clientId: "test cancel order",
      });
      const cancelSignature = await client.createOrderCancellationSignature({
        symbol,
        hashes: [response.response.data.hash],
      });
      const cancellationResponse = await client.placeCancelOrder({
        symbol,
        hashes: [response.response.data.hash],
        signature: cancelSignature,
      });
      expect(cancellationResponse.ok).to.be.equal(true);
    });

    it("should get Invalid Order Signature error", async () => {
      const signedOrder = await client.createSignedOrder({
        symbol,
        price: sellPrice,
        quantity: 0.001,
        side: ORDER_SIDE.SELL,
        leverage: defaultLeverage,
        orderType: ORDER_TYPE.LIMIT,
      });
      const response = await client.placeSignedOrder({ ...signedOrder });
      const cancellationResponse = await client.placeCancelOrder({
        symbol,
        hashes: [response.response.data.hash],
        signature: "0xSomeRandomStringWhichIsNotACorrectSignature",
      });

      expect(cancellationResponse.ok).to.be.equal(false);
      expect(cancellationResponse.response.message).to.be.equal(
        "Invalid Order Signature"
      );
    });

    it("should post a cancel order on exchange", async () => {
      const response = await client.postOrder({
        symbol,
        price: sellPrice + 2,
        quantity: 0.1,
        side: ORDER_SIDE.SELL,
        leverage: defaultLeverage,
        orderType: ORDER_TYPE.LIMIT,
      });
      expect(response.ok).to.be.equal(true);

      const cancelResponse = await client.postCancelOrder({
        symbol,
        hashes: [response?.data?.hash as string],
      });

      expect(cancelResponse.ok).to.be.equal(true);
    });

    it("should cancel all open orders", async () => {
      const response = await client.cancelAllOpenOrders(symbol);
      expect(response.ok).to.be.equal(true);
    });

    it("should cancel all open orders on behalf of parent account", async () => {
      const response = await client.cancelAllOpenOrders(
        symbol,
        testAcctPubAddr
      );
      expect(response.ok).to.be.equal(true);
    });

    xit("should cancel STOP LIMIT order on exchange", async () => {
      const response = await client.postOrder({
        symbol,
        quantity: 0.1,
        side: ORDER_SIDE.SELL,
        leverage: defaultLeverage,
        orderType: ORDER_TYPE.STOP_LIMIT,
        price: indexPrice - 4,
        triggerPrice: indexPrice - 2,
      });
      expect(response.ok).to.be.equal(true);

      const cancelResponse = await client.postCancelOrder({
        symbol,
        hashes: [response?.data?.hash as string],
      });

      expect(cancelResponse.ok).to.be.equal(true);
    });

    xit("should cancel STOP MARKET order on exchange", async () => {
      const response = await client.postOrder({
        symbol,
        quantity: 0.1,
        side: ORDER_SIDE.SELL,
        leverage: defaultLeverage,
        orderType: ORDER_TYPE.STOP_MARKET,
        price: indexPrice - 4,
        triggerPrice: indexPrice - 2,
      });
      expect(response.ok).to.be.equal(true);

      const cancelResponse = await client.postCancelOrder({
        symbol,
        hashes: [response?.data?.hash as string],
      });

      expect(cancelResponse.ok).to.be.equal(true);
    });
  });

  describe("Get User Orders", () => {
    it("should get all open orders", async () => {
      const data = await client.getUserOrders({
        statuses: [ORDER_STATUS.OPEN],
        symbol,
      });
      expect(data.ok).to.be.equals(true);
      expect(data.response.data.length).to.be.gte(0);
    });

    xit("should get all stand by stop orders", async () => {
      const data = await client.getUserOrders({
        statuses: [ORDER_STATUS.STAND_BY, ORDER_STATUS.STAND_BY_PENDING],
        symbol,
      });
      expect(data.ok).to.be.equals(true);
      expect(data.response.data.length).to.be.gte(0);
    });

    xit("should get all open orders on behalf of parent account", async () => {
      // make sure to first whitelist the subaccount with the below parent account to run this test.
      // To whitelist the subaccount use the above test {set sub account}
      // and subaccount must be authenticated/initialized with the client.
      const data = await client.getUserOrders({
        statuses: [ORDER_STATUS.OPEN],
        symbol,
        parentAddress:
          "0xFEa83f912CF21d884CDfb66640CfAB6029D940aF".toLowerCase(),
      });
      expect(data.ok).to.be.equals(true);
      expect(data.response.data.length).to.be.gte(0);
    });

    it("should handle get open orders of non-existent hashes", async () => {
      const data = await client.getUserOrders({
        statuses: [ORDER_STATUS.OPEN],
        symbol,
        orderHashes: ["test0"], // incorrect hash
      });
      expect(data.ok).to.be.equals(true);
      expect(data.response.data.length).to.be.eq(0);
    });

    it("should get open orders of specific hashes", async () => {
      const data = await client.getUserOrders({
        statuses: [ORDER_STATUS.OPEN],
        symbol,
      });
      if (data.ok && data.data!.length > 0) {
        const data1 = await client.getUserOrders({
          statuses: [ORDER_STATUS.OPEN],
          symbol,
          orderHashes: data.response.data[0].hash,
        });

        expect(data1.ok).to.be.equals(true);
        expect(data1.data!.length).to.be.eq(1);
      }

      expect(data.ok).to.be.equals(true);
    });

    it("should get all cancelled orders", async () => {
      const data = await client.getUserOrders({
        statuses: [ORDER_STATUS.CANCELLED],
        symbol,
      });
      expect(data.ok).to.be.equal(true);
    });

    it("should get cancelled orders", async () => {
      const data = await client.getUserOrders({
        statuses: [ORDER_STATUS.CANCELLED],
        symbol,
        pageSize: 1,
      });
      expect(data.ok).to.be.equals(true);
    });

    it("should get 0 expired orders as page 10 does not exist for expired orders", async () => {
      const data = await client.getUserOrders({
        statuses: [ORDER_STATUS.EXPIRED],
        symbol,
        pageNumber: 10,
      });
      expect(data.response.data.length).to.be.equals(0);
    });

    it("should get only LIMIT filled orders", async () => {
      const data = await client.getUserOrders({
        statuses: [ORDER_STATUS.FILLED],
        orderType: [ORDER_TYPE.LIMIT],
        symbol,
      });
      expect(data.ok).to.be.equals(true);
      expect(data.response.data.length).to.be.gte(0);
    });
  });

  describe("Get User Position", () => {
    beforeEach(async () => {
      //   client.addMarket(symbol);
    });

    it("should return zero open positions for the user", async () => {
      // Given
      const clientTemp = new BluefinClient(true, network);
      await clientTemp.init();

      const response = await clientTemp.getUserPosition({});

      // Then
      expect(response.ok).to.be.equal(true);
      expect(response.response.data.length).to.be.equal(0);

      clientTemp.sockets.close();
    });

    it("should get user's BTC-PERP Position", async () => {
      const response = await client.getUserPosition({
        symbol,
      });

      const position = response.data as any as GetPositionResponse;
      if (Object.keys(position).length > 0) {
        expect(response.response.data.symbol).to.be.equal(symbol);
      }
    });

    it("should get all open positions for the user across all markets", async () => {
      const response = await client.getUserPosition({});
      expect(response.ok).to.be.equal(true);
    });
  });

  describe("Get User Trades", () => {
    beforeEach(async () => {
      //   client.addMarket(symbol);
    });

    it("should return zero trades for the user", async () => {
      // Given
      //   const web3 = new Web3(network.url);
      //   const wallet = web3.eth.accounts.create();
      const clientTemp = new BluefinClient(true, network);
      await clientTemp.init();

      // When
      //   clientTemp.addMarket(symbol);
      const response = await clientTemp.getUserTrades({});

      // Then
      expect(response.ok).to.be.equal(true);
      expect(response.response.data.length).to.be.equal(0);
      clientTemp.sockets.close();
    });

    it("should get user's BTC-PERP Trades", async () => {
      const response = await client.getUserTrades({
        symbol,
      });
      expect(response.ok).to.be.equal(true);
    });

    it("should return zero trades history for the user", async () => {
      // Given
      //   const web3 = new Web3(network.url);
      //   const wallet = web3.eth.accounts.create();
      const clientTemp = new BluefinClient(true, network);
      await clientTemp.init();

      // When
      //   clientTemp.addMarket(symbol);
      const response = await clientTemp.getUserTradesHistory({});

      // Then
      expect(response.ok).to.be.equal(true);
      expect(response.response.data.data.length).to.be.equal(0);
      clientTemp.sockets.close();
    });
    it("should get user's BTC-PERP Trades History", async () => {
      const response = await client.getUserTradesHistory({
        symbol,
      });
      expect(response.ok).to.be.equal(true);
    });
  });

  describe("Get Market Orderbook", () => {
    it(`should get ${symbol} orderbook with best ask and bid`, async () => {
      const response = await client.getOrderbook({
        symbol,
        limit: 1,
      });
      expect(response.ok).to.be.equal(true);
      expect(response?.data?.limit).to.be.equal(1);
      expect(response?.data?.symbol).to.be.equal(symbol);
    });

    it("should get no orderbook data as market for DOGE-PERP does not exist", async () => {
      const response = await client.getOrderbook({
        symbol: "DODGE-PERP",
        limit: 1,
      });
      expect(response.ok).to.be.equal(false);
    });
  });

  describe("User History and Account Related Routes", async () => {
    it("should get User Account Data", async () => {
      const response = await client.getUserAccountData();
      expect(response.ok).to.be.equal(true);
    });

    it("should get Transaction History records for user", async () => {
      const response = await client.getUserTransactionHistory({
        symbol,
        pageSize: 2,
        pageNumber: 1,
      });
      expect(response.ok).to.be.equal(true);
    });

    it("should get Funding History records for user", async () => {
      const response = await client.getUserFundingHistory({
        pageSize: 2,
        cursor: 1,
      });
      expect(response.ok).to.be.equal(true);
    });

    it(`should get Funding History records of ${symbol}`, async () => {
      const response = await client.getUserFundingHistory({
        symbol,
        pageSize: 2,
        cursor: 1,
      });
      expect(response.ok).to.be.equal(true);
    });

    it("should get all Transfer History records for user", async () => {
      const response = await client.getUserTransferHistory({});
      expect(response.ok).to.be.equal(true);
    });

    it("should get Transfer History of `Withdraw` records for user", async () => {
      const response = await client.getUserTransferHistory({
        action: "Withdraw",
      });
      expect(response.ok).to.be.equal(true);
    });

    it("should fetch offchain updates of the user", async () => {
      const response = await client.getOffchainSettlementUpdates({});
      expect(response.ok).to.be.equal(true);
    });
    it(`should only fetch offchain updates of ${symbol}`, async () => {
      const response = await client.getOffchainSettlementUpdates({
        symbol: symbol,
        pageSize: 2,
      });
      expect(response.ok).to.be.equal(true);
      expect(response.data.data.length).to.be.lte(2);
    });
    it(`should only fetch offchain updates with action type = SENT_FOR_SETTLEMENT`, async () => {
      const response = await client.getOffchainSettlementUpdates({
        symbol: symbol,
        action: [OffchainOrderUpdateAction.sentForSettlement],
        pageSize: 2,
      });
      expect(response.ok).to.be.equal(true);
      expect(response.data.data.length).to.be.lte(2);
    });
  });

  it("should get contract address", async () => {
    const response = await client.getContractAddresses();
    expect(response.ok).to.be.equal(true);
  });

  it("should get recent market trades of BTC-PERP Market", async () => {
    const response = await client.getMarketRecentTrades({
      symbol,
    });
    expect(response.ok).to.be.equal(true);
  });

  it("should get candle stick data", async () => {
    const response = await client.getMarketCandleStickData({
      symbol,
      interval: "1m",
    });
    expect(response.ok).to.be.equal(true);
  });

  it("should get exchange info for BTC Market", async () => {
    const response = await client.getExchangeInfo(symbol);
    expect(response.ok).to.be.equal(true);
    expect(response.data?.symbol).to.be.equal(symbol);
  });

  it("should get exchange info for all markets", async () => {
    const response = await client.getExchangeInfo();
    expect(response.ok).to.be.equal(true);
    expect(response.response.data.length).to.be.gte(1);
  });

  it("should get market data for BTC Market", async () => {
    const response = await client.getMarketData(symbol);
    expect(response.ok).to.be.equal(true);
  });

  it("should get market meta info for BTC Market", async () => {
    const response = await client.getMarketMetaInfo(symbol);
    expect(response.ok).to.be.equal(true);
  });

  it("should get market ticker data for BTC Market", async () => {
    const response = await client.getTickerData(symbol);
    expect(response.ok).to.be.equal(true);
  });

  it("should get master info of all markets", async () => {
    const response = await client.getMasterInfo();
    expect(response.ok).to.be.equal(true);
  });

  it(`should get master info of ${symbol}`, async () => {
    const response = await client.getMasterInfo(symbol);
    expect(response.ok).to.be.equal(true);
  });

  it("should get market symbols", async () => {
    const response = await client.getMarketSymbols();
    expect(response.ok).to.be.equal(true);
  });

  it("should get status of exchange to be alive", async () => {
    const response = await client.getExchangeStatus();
    expect(response.ok).to.be.equal(true);
    expect(response.data?.isAlive).to.be.equal(true);
  });

  it(`should return funding rate of ${symbol}`, async () => {
    const response = await client.getMarketFundingRate(symbol);
    expect(response.ok).to.be.equal(true);
  });

  it(`should return verification status`, async () => {
    const response = await client.verifyWalletStatus(100);
    expect(response.ok).to.be.equal(true);
  });

  describe("Growth Routes", async () => {
    it("should not generate referral code for non affiliated user", async () => {
      const response = await client.generateReferralCode({
        referralCode: "testReferCode",
        campaignId: 2,
      });
      expect(response.ok).to.be.equal(false);
      expect((response?.data as any).error?.code).to.be.equal(3078);
    });
    it("should not link referred user when given incorrect refer code", async () => {
      const response = await client.affiliateLinkReferredUser({
        referralCode: "testReferCode",
      });
      expect(response.ok).to.be.equal(false);
      expect((response?.data as any).error?.code).to.be.equal(9000);
    });
    it("should get referrer info", async () => {
      const response = await client.getReferrerInfo();
      expect(response.ok).to.be.equal(true);
    });
    it("should get campaign details", async () => {
      const response = await client.getCampaignDetails();
      expect(response.ok).to.be.equal(true);
    });
    it("should get campaign rewards", async () => {
      const response = await client.getCampaignRewards(3);
      expect(response.ok).to.be.equal(true);
    });
    it("should get user rewards history", async () => {
      const response = await client.getUserRewardsHistory();
      expect(response.ok).to.be.equal(true);
    });
    it("should get user rewards summary", async () => {
      const response = await client.getUserRewardsSummary();
      expect(response.ok).to.be.equal(true);
    });
    it("should get trade & earn rewards overview", async () => {
      const response = await client.getTradeAndEarnRewardsOverview(2);
      expect(response.ok).to.be.equal(true);
    });
    it("should get trade & earn rewards details", async () => {
      const response = await client.getTradeAndEarnRewardsDetail({
        campaignId: 3,
      });
      expect(response.ok).to.be.equal(true);
    });
    it("should get trade & earn historical rewards total", async () => {
      const response = await client.getTotalHistoricalTradingRewards();
      expect(response.ok).to.be.equal(true);
    });
    it("should not get affiliate payouts when user is not an affiliate", async () => {
      const response = await client.getAffiliatePayouts(1);
      expect(response.ok).to.be.equal(false);
      expect((response?.data as any).error?.code).to.be.equal(3078);
    });
    it("should not get affiliate referee details when user is not an affiliate", async () => {
      const response = await client.getAffiliateRefereeDetails({
        campaignId: 2,
      });
      expect(response.ok).to.be.equal(false);
      expect((response?.data as any).error?.code).to.be.equal(3078);
    });
    it("should not get affiliate count when user is not an affiliate", async () => {
      const response = await client.getAffiliateRefereeCount(2);
      expect(response.ok).to.be.equal(false);
      expect((response?.data as any).error?.code).to.be.equal(9000);
    });
  });

  describe("Sockets", () => {
    beforeEach(async () => {
      client.sockets.open();
      //   client.addMarket(symbol);
      client.sockets.subscribeGlobalUpdatesBySymbol(symbol);
      client.sockets.subscribeUserUpdateByToken();
    });

    it("should receive an event from candle stick", (done) => {
      const callback = (candle: MinifiedCandleStick) => {
        expect(candle[candle.length - 1]).to.be.equal(symbol);
        done();
      };
      client.sockets.onCandleStickUpdate(symbol, "1m", callback);
    });

    it("should receive an event for orderbook update when an order is placed on exchange", (done) => {
      const callback = ({ orderbook }: any) => {
        expect(orderbook.symbol).to.be.equal(symbol);
        done();
      };

      client.sockets.onOrderBookUpdate(callback);

      // wait for 1 sec as room might not had been subscribed
      setTimeout(1000).then(() => {
        client.postOrder({
          symbol,
          price: sellPrice + 3,
          quantity: 0.1,
          side: ORDER_SIDE.SELL,
          leverage: defaultLeverage,
          orderType: ORDER_TYPE.LIMIT,
        });
      });
    });

    it("should receive an event for ticker update", (done) => {
      const callback = (tickerUpdate: TickerData[]) => {
        expect(tickerUpdate.length).to.be.greaterThan(0);
        done();
      };

      client.sockets.onTickerUpdate(callback);
    });

    it("should receive an event when a trade is performed", (done) => {
      const callback = ({
        trades,
      }: {
        trades: GetMarketRecentTradesResponse[];
      }) => {
        expect(trades[0].symbol).to.be.equal(symbol);
        done();
      };

      client.sockets.onRecentTrades(callback);

      // wait for 1 sec as room might not had been subscribed
      setTimeout(1000).then(() => {
        client.postOrder({
          symbol,
          price: 0,
          quantity: 0.1,
          side: ORDER_SIDE.SELL,
          leverage: defaultLeverage,
          orderType: ORDER_TYPE.MARKET,
        });
      });
    });

    it("should receive order update event", (done) => {
      const callback = ({ order }: { order: PlaceOrderResponse }) => {
        expect(order.symbol).to.be.equal(symbol);
        done();
      };

      client.sockets.onUserOrderUpdate(callback);

      // wait for 1 sec as room might not had been subscribed
      setTimeout(1000).then(() => {
        client.postOrder({
          symbol,
          price: sellPrice + 1,
          quantity: 0.1,
          side: ORDER_SIDE.SELL,
          leverage: defaultLeverage,
          orderType: ORDER_TYPE.LIMIT,
        });
      });
    });

    it("should receive position update event", (done) => {
      const callback = ({ position }: { position: GetPositionResponse }) => {
        expect(position.userAddress).to.be.equal(
          client.getPublicAddress().toLocaleLowerCase()
        );
        done();
      };

      client.sockets.onUserPositionUpdate(callback);

      // wait for 1 sec as room might not had been subscribed
      setTimeout(1000).then(() => {
        client.postOrder({
          symbol,
          price: 0,
          quantity: 0.1,
          side: ORDER_SIDE.BUY,
          leverage: defaultLeverage,
          orderType: ORDER_TYPE.MARKET,
        });
      });
    });

    it("should receive user update event", (done) => {
      const callback = ({ trade }: { trade: GetUserTradesResponse }) => {
        expect(trade.maker).to.be.equal(false);
        expect(trade.symbol).to.be.equal(symbol);
        done();
      };

      client.sockets.onUserUpdates(callback);

      // wait for 1 sec as room might not had been subscribed
      setTimeout(1000).then(() => {
        client.postOrder({
          symbol,
          price: 0,
          quantity: 0.1,
          side: ORDER_SIDE.BUY,
          leverage: defaultLeverage,
          orderType: ORDER_TYPE.MARKET,
        });
      });
    });

    it("should receive user account update event", (done) => {
      const callback = ({
        accountData,
      }: {
        accountData: GetAccountDataResponse;
      }) => {
        expect(accountData.address).to.be.equal(
          client.getPublicAddress().toLocaleLowerCase()
        );
        done();
      };

      client.sockets.onUserAccountDataUpdate(callback);

      // wait for 1 sec as room might not had been subscribed
      setTimeout(1000).then(() => {
        client.postOrder({
          symbol,
          price: 0,
          quantity: 0.1,
          side: ORDER_SIDE.BUY,
          leverage: defaultLeverage,
          orderType: ORDER_TYPE.MARKET,
        });
      });
    });
    it("should receive an sent for settlement event when trade is performed", (done) => {
      const callback = (update: OrderSentForSettlementUpdateResponse) => {
        expect(update.symbol).to.be.equal(symbol);
        done();
      };

      client.sockets.onUserOrderSentForSettlementUpdate(callback);

      // wait for 1 sec as room might not had been subscribed
      setTimeout(1000).then(async () => {
        client.postOrder({
          symbol,
          price: 0,
          quantity: 0.001,
          side: ORDER_SIDE.SELL,
          leverage: defaultLeverage,
          orderType: ORDER_TYPE.MARKET,
        });
      });
    });
  });

  describe("WebSockets", () => {
    beforeEach(async () => {
      //   client.addMarket(symbol);
      await client.webSockets?.open();
      client.webSockets?.subscribeGlobalUpdatesBySymbol(symbol);
      client.webSockets?.subscribeUserUpdateByToken();
    });

    afterEach(() => {
      client.webSockets?.close();
    });

    it("WebSocket Client: should receive an event from candle stick", (done) => {
      const callback = (candle: MinifiedCandleStick) => {
        expect(candle[candle.length - 1]).to.be.equal(symbol);
        done();
      };
      client.webSockets?.onCandleStickUpdate(symbol, "1m", callback);
    });

    it("WebSocket Client: should receive an event for orderbook update when an order is placed on exchange", (done) => {
      const callback = ({ orderbook }: any) => {
        expect(orderbook.symbol).to.be.equal(symbol);
        done();
      };

      client.webSockets?.onOrderBookUpdate(callback);

      // wait for 1 sec as room might not had been subscribed
      setTimeout(1000).then(() => {
        client.postOrder({
          symbol,
          price: sellPrice + 3,
          quantity: 0.1,
          side: ORDER_SIDE.SELL,
          leverage: defaultLeverage,
          orderType: ORDER_TYPE.LIMIT,
        });
      });
    });

    it("WebSocket Client: should receive an event for ticker update", (done) => {
      const callback = (tickerUpdate: TickerData[]) => {
        expect(tickerUpdate.length).to.be.greaterThan(0);
        done();
      };

      client.webSockets?.onTickerUpdate(callback);
    });

    it("WebSocket Client: should receive an event when a trade is performed", (done) => {
      const callback = ({
        trades,
      }: {
        trades: GetMarketRecentTradesResponse[];
      }) => {
        expect(trades[0].symbol).to.be.equal(symbol);
        done();
      };

      client.webSockets?.onRecentTrades(callback);

      // wait for 1 sec as room might not had been subscribed
      setTimeout(1000).then(() => {
        client.postOrder({
          symbol,
          price: 0,
          quantity: 0.1,
          side: ORDER_SIDE.BUY,
          leverage: defaultLeverage,
          orderType: ORDER_TYPE.MARKET,
        });
      });
    });

    it("WebSocket Client: should receive order update event", (done) => {
      const callback = ({ order }: { order: PlaceOrderResponse }) => {
        expect(order.symbol).to.be.equal(symbol);
        done();
      };

      client.webSockets?.onUserOrderUpdate(callback);

      // wait for 1 sec as room might not had been subscribed
      setTimeout(1000).then(() => {
        client.postOrder({
          symbol,
          price: sellPrice + 1,
          quantity: 0.1,
          side: ORDER_SIDE.BUY,
          leverage: defaultLeverage,
          orderType: ORDER_TYPE.LIMIT,
        });
      });
    });

    it("WebSocket Client: should receive position update event", (done) => {
      const callback = ({ position }: { position: GetPositionResponse }) => {
        expect(position.userAddress).to.be.equal(
          client.getPublicAddress().toLocaleLowerCase()
        );
        done();
      };

      client.webSockets?.onUserPositionUpdate(callback);

      // wait for 1 sec as room might not had been subscribed
      setTimeout(1000).then(() => {
        client.postOrder({
          symbol,
          price: 0,
          quantity: 0.1,
          side: ORDER_SIDE.BUY,
          leverage: defaultLeverage,
          orderType: ORDER_TYPE.MARKET,
        });
      });
    });

    it("WebSocket Client: should receive user update event", (done) => {
      const callback = ({ trade }: { trade: GetUserTradesResponse }) => {
        expect(trade.maker).to.be.equal(false);
        expect(trade.symbol).to.be.equal(symbol);
        done();
      };

      client.webSockets?.onUserUpdates(callback);

      // wait for 1 sec as room might not had been subscribed
      setTimeout(1000).then(() => {
        client.postOrder({
          symbol,
          price: 0,
          quantity: 0.1,
          side: ORDER_SIDE.BUY,
          leverage: defaultLeverage,
          orderType: ORDER_TYPE.MARKET,
        });
      });
    });

    it("WebSocket Client: should receive user account update event", (done) => {
      const callback = ({
        accountData,
      }: {
        accountData: GetAccountDataResponse;
      }) => {
        expect(accountData.address).to.be.equal(
          client.getPublicAddress().toLocaleLowerCase()
        );
        done();
      };

      client.webSockets?.onUserAccountDataUpdate(callback);

      // wait for 1 sec as room might not had been subscribed
      setTimeout(1000).then(() => {
        client.postOrder({
          symbol,
          price: 0,
          quantity: 0.1,
          side: ORDER_SIDE.BUY,
          leverage: defaultLeverage,
          orderType: ORDER_TYPE.MARKET,
        });
      });
    });
    it("WebSocket Client: should receive an sent for settlement event when trade is performed", (done) => {
      const callback = (update: OrderSentForSettlementUpdateResponse) => {
        expect(update.symbol).to.be.equal(symbol);
        done();
      };

      client.webSockets?.onUserOrderSentForSettlementUpdate(callback);

      // wait for 1 sec as room might not had been subscribed
      setTimeout(1000).then(async () => {
        client.postOrder({
          symbol,
          price: 0,
          quantity: 0.001,
          side: ORDER_SIDE.SELL,
          leverage: defaultLeverage,
          orderType: ORDER_TYPE.MARKET,
        });
      });
    });
  });

  describe("Cancel On Disconnect - DMS", () => {
    beforeEach(async () => {
      //   client.addMarket(symbol);
    });

    it("should return 1 market accepted for countdown reset", async () => {
      // When
      const response = await client.resetCancelOnDisconnectTimer({
        countDowns: [
          {
            symbol,
            countDown: 200000,
          },
        ],
      });

      // remove countdown
      await client.resetCancelOnDisconnectTimer({
        countDowns: [
          {
            symbol,
            countDown: 0,
          },
        ],
      });
      // Then
      expect(response.ok).to.be.equal(true);
      expect(
        response.response.data.acceptedToReset.length
      ).to.be.greaterThanOrEqual(1);
    });

    it("should get user's symbol's countdown", async () => {
      // When
      await client.resetCancelOnDisconnectTimer({
        countDowns: [
          {
            symbol,
            countDown: 200000,
          },
        ],
      });
      const response = await client.getCancelOnDisconnectTimer(symbol);
      // Then
      // remove countdown
      await client.resetCancelOnDisconnectTimer({
        countDowns: [
          {
            symbol,
            countDown: 0,
          },
        ],
      });
      expect(response.ok).to.be.equal(true);
      expect(response.response.data.countDowns.length).to.be.greaterThanOrEqual(
        1
      );
    });

    it("should cancel user's symbol's countdown", async () => {
      // When
      await client.resetCancelOnDisconnectTimer({
        countDowns: [
          {
            symbol,
            countDown: 200000,
          },
        ],
      });
      // remove countdown
      await client.resetCancelOnDisconnectTimer({
        countDowns: [
          {
            symbol,
            countDown: 0,
          },
        ],
      });

      const response = await client.getCancelOnDisconnectTimer(symbol);
      // Then
      expect(response.ok).to.be.equal(true);
      expect(response.response.data.countDowns.length).to.be.greaterThanOrEqual(
        0
      );
    });
  });
});
describe("BluefinClient via ReadOnlyToken", () => {
  //* set environment from here
  const symbol = "ETH-PERP";
  let defaultLeverage = 3;
  let sellPrice = 20000;
  let buyPrice = 18000;
  let marketPrice = 0;
  let indexPrice = 1600;
  let readOnlyToken = "";
  let readOnlyClient: BluefinClient;

  before(async () => {
    client = new BluefinClient(true, network, testAcctKey, "ED25519");
    await client.init();
    // TODO! uncomment when done testing specifically on BTC-PERP
    // const allSymbols = await client.getMarketSymbols();
    // get first symbol to run tests on
    // if (allSymbols.data) {
    //   symbol = allSymbols.data[0];
    // }
    // TODO! uncomment above code when done testing specifically on BTC-PERP

    console.log(`--- Trading symbol: ${symbol} ---`);

    // get default leverage
    defaultLeverage = await client.getUserDefaultLeverage(symbol);
    console.log(`- on leverage: ${defaultLeverage}`);

    // market data
    const marketData = await client.getMarketData(symbol);
    if (marketData.data && toBaseNumber(marketData.data.marketPrice) > 0) {
      marketPrice = toBaseNumber(marketData.data.marketPrice);
      indexPrice = toBaseNumber(marketData.data.indexPrice || "0");
      const percentChange = 3 / 100; // 3%
      buyPrice = Number((marketPrice - marketPrice * percentChange).toFixed(0));
      sellPrice = Number(
        (marketPrice + marketPrice * percentChange).toFixed(0)
      );
      console.log(`- market price: ${marketPrice}`);
      console.log(`- index price: ${indexPrice}`);
    }
    const response = await await client.generateReadOnlyToken();
    if (response.data) {
      readOnlyToken = response.data;
    }
  });

  beforeEach(async () => {
    client = new BluefinClient(true, network, testAcctKey);
    await client.init();

    readOnlyClient = new BluefinClient(true, network);
    await readOnlyClient.init(true, readOnlyToken);
  });

  afterEach(() => {
    client.sockets.close();
  });

  it("should initialize the client", async () => {
    readOnlyClient = new BluefinClient(true, network);
    await readOnlyClient.init(true, readOnlyToken);
    expect(readOnlyClient).to.be.not.eq(undefined);
  });

  describe("Get User Orders", () => {
    it("should get all open orders", async () => {
      const data = await readOnlyClient.getUserOrders({
        statuses: [ORDER_STATUS.OPEN],
        symbol,
      });
      expect(data.ok).to.be.equals(true);
      expect(data.response.data.length).to.be.gte(0);
    });

    it("should get all stand by stop orders", async () => {
      const data = await readOnlyClient.getUserOrders({
        statuses: [ORDER_STATUS.STAND_BY, ORDER_STATUS.STAND_BY_PENDING],
        symbol,
      });
      expect(data.ok).to.be.equals(true);
      expect(data.response.data.length).to.be.gte(0);
    });

    it("should handle get open orders of non-existent hashes", async () => {
      const data = await readOnlyClient.getUserOrders({
        statuses: [ORDER_STATUS.OPEN],
        symbol,
        orderHashes: ["test0"], // incorrect hash
      });
      expect(data.ok).to.be.equals(true);
      expect(data.response.data.length).to.be.eq(0);
    });

    it("should get open orders of specific hashes", async () => {
      const data = await readOnlyClient.getUserOrders({
        statuses: [ORDER_STATUS.OPEN],
        symbol,
      });
      if (data.ok && data.data!.length > 0) {
        const data1 = await client.getUserOrders({
          statuses: [ORDER_STATUS.OPEN],
          symbol,
          orderHashes: data.response.data[0].hash,
        });

        expect(data1.ok).to.be.equals(true);
        expect(data1.data!.length).to.be.eq(1);
      }

      expect(data.ok).to.be.equals(true);
    });

    it("should get all cancelled orders", async () => {
      const data = await readOnlyClient.getUserOrders({
        statuses: [ORDER_STATUS.CANCELLED],
        symbol,
      });
      expect(data.ok).to.be.equal(true);
    });

    it("should get cancelled orders", async () => {
      const data = await readOnlyClient.getUserOrders({
        statuses: [ORDER_STATUS.CANCELLED],
        symbol,
        pageSize: 1,
      });
      expect(data.ok).to.be.equals(true);
    });

    it("should get 0 expired orders as page 10 does not exist for expired orders", async () => {
      const data = await readOnlyClient.getUserOrders({
        statuses: [ORDER_STATUS.EXPIRED],
        symbol,
        pageNumber: 10,
      });
      expect(data.response.data.length).to.be.equals(0);
    });

    it("should get only LIMIT filled orders", async () => {
      const data = await readOnlyClient.getUserOrders({
        statuses: [ORDER_STATUS.FILLED],
        orderType: [ORDER_TYPE.LIMIT],
        symbol,
      });
      expect(data.ok).to.be.equals(true);
      expect(data.response.data.length).to.be.gte(0);
    });
  });

  describe("Get User Position", () => {
    it("should get user's BTC-PERP Position", async () => {
      const response = await readOnlyClient.getUserPosition({
        symbol,
      });

      const position = response.data as any as GetPositionResponse;
      if (Object.keys(position).length > 0) {
        expect(response.response.data.symbol).to.be.equal(symbol);
      }
    });

    it("should get all open positions for the user across all markets", async () => {
      const response = await readOnlyClient.getUserPosition({});
      expect(response.ok).to.be.equal(true);
    });
  });

  describe("Get User Trades", () => {
    it("should get user's BTC-PERP Trades", async () => {
      const response = await readOnlyClient.getUserTrades({
        symbol,
      });
      expect(response.ok).to.be.equal(true);
    });
    it("should get user's BTC-PERP Trades History", async () => {
      const response = await readOnlyClient.getUserTradesHistory({
        symbol,
      });
      expect(response.ok).to.be.equal(true);
    });
  });

  describe("Get Market Orderbook", () => {
    it(`should get ${symbol} orderbook with best ask and bid`, async () => {
      const response = await readOnlyClient.getOrderbook({
        symbol,
        limit: 1,
      });
      expect(response.ok).to.be.equal(true);
      expect(response?.data?.limit).to.be.equal(1);
      expect(response?.data?.symbol).to.be.equal(symbol);
    });

    it("should get no orderbook data as market for DOGE-PERP does not exist", async () => {
      const response = await readOnlyClient.getOrderbook({
        symbol: "DODGE-PERP",
        limit: 1,
      });
      expect(response.ok).to.be.equal(false);
    });
  });

  describe("User History and Account Related Routes", async () => {
    it("should get User Account Data", async () => {
      const response = await readOnlyClient.getUserAccountData();
      expect(response.ok).to.be.equal(true);
    });

    it("should get Transaction History records for user", async () => {
      const response = await client.getUserTransactionHistory({
        symbol,
        pageSize: 2,
        pageNumber: 1,
      });
      expect(response.ok).to.be.equal(true);
    });

    it("should get Funding History records for user", async () => {
      const response = await client.getUserFundingHistory({
        pageSize: 2,
        cursor: 1,
      });
      expect(response.ok).to.be.equal(true);
    });

    it(`should get Funding History records of ${symbol}`, async () => {
      const response = await client.getUserFundingHistory({
        symbol,
        pageSize: 2,
        cursor: 1,
      });
      expect(response.ok).to.be.equal(true);
    });

    it("should get all Transfer History records for user", async () => {
      const response = await client.getUserTransferHistory({});
      expect(response.ok).to.be.equal(true);
    });

    it("should get Transfer History of `Withdraw` records for user", async () => {
      const response = await client.getUserTransferHistory({
        action: "Withdraw",
      });
      expect(response.ok).to.be.equal(true);
    });
  });

  describe("Growth Routes", async () => {
    it("should not allow generate referral code on readOnlyToken", async () => {
      const response = await readOnlyClient.generateReferralCode({
        referralCode: "testReferCode",
        campaignId: 2,
      });
      expect(response.ok).to.be.equal(false);
      expect((response?.data as any).error?.code).to.be.equal(2004);
    });
    it("should not allow link referred user on readOnlyToken", async () => {
      const response = await readOnlyClient.affiliateLinkReferredUser({
        referralCode: "testReferCode",
      });
      expect(response.ok).to.be.equal(false);
      expect((response?.data as any).error?.code).to.be.equal(2004);
    });
    it("should get referrer info", async () => {
      const response = await readOnlyClient.getReferrerInfo();
      expect(response.ok).to.be.equal(true);
    });
    it("should get campaign details", async () => {
      const response = await readOnlyClient.getCampaignDetails();
      expect(response.ok).to.be.equal(true);
    });
    it("should get campaign rewards", async () => {
      const response = await readOnlyClient.getCampaignRewards(3);
      expect(response.ok).to.be.equal(true);
    });
    it("should get user rewards history", async () => {
      const response = await readOnlyClient.getUserRewardsHistory();
      expect(response.ok).to.be.equal(true);
    });
    it("should get user rewards summary", async () => {
      const response = await readOnlyClient.getUserRewardsSummary();
      expect(response.ok).to.be.equal(true);
    });
    it("should get trade & earn rewards overview", async () => {
      const response = await readOnlyClient.getTradeAndEarnRewardsOverview(2);
      expect(response.ok).to.be.equal(true);
    });
    it("should get trade & earn rewards details", async () => {
      const response = await readOnlyClient.getTradeAndEarnRewardsDetail({
        campaignId: 3,
      });
      expect(response.ok).to.be.equal(true);
    });
    it("should get trade & earn historical rewards total", async () => {
      const response = await readOnlyClient.getTotalHistoricalTradingRewards();
      expect(response.ok).to.be.equal(true);
    });
    it("should not get affiliate payouts when user is not an affiliate", async () => {
      const response = await readOnlyClient.getAffiliatePayouts(1);
      expect(response.ok).to.be.equal(false);
      expect((response?.data as any).error?.code).to.be.equal(3078);
    });
    it("should not get affiliate referee details when user is not an affiliate", async () => {
      const response = await readOnlyClient.getAffiliateRefereeDetails({
        campaignId: 2,
      });
      expect(response.ok).to.be.equal(false);
      expect((response?.data as any).error?.code).to.be.equal(3078);
    });
    it("should not get affiliate count when user is not an affiliate", async () => {
      const response = await readOnlyClient.getAffiliateRefereeCount(2);
      expect(response.ok).to.be.equal(false);
      expect((response?.data as any).error?.code).to.be.equal(9000);
    });
  });

  it("should get contract address", async () => {
    const response = await readOnlyClient.getContractAddresses();
    expect(response.ok).to.be.equal(true);
  });

  it("should get recent market trades of BTC-PERP Market", async () => {
    const response = await readOnlyClient.getMarketRecentTrades({
      symbol,
    });
    expect(response.ok).to.be.equal(true);
  });

  it("should get candle stick data", async () => {
    const response = await readOnlyClient.getMarketCandleStickData({
      symbol,
      interval: "1m",
    });
    expect(response.ok).to.be.equal(true);
  });

  it("should get exchange info for BTC Market", async () => {
    const response = await readOnlyClient.getExchangeInfo(symbol);
    expect(response.ok).to.be.equal(true);
    expect(response.data?.symbol).to.be.equal(symbol);
  });

  it("should get exchange info for all markets", async () => {
    const response = await readOnlyClient.getExchangeInfo();
    expect(response.ok).to.be.equal(true);
    expect(response.response.data.length).to.be.gte(1);
  });

  it("should get market data for BTC Market", async () => {
    const response = await readOnlyClient.getMarketData(symbol);
    expect(response.ok).to.be.equal(true);
  });

  it("should get market meta info for BTC Market", async () => {
    const response = await readOnlyClient.getMarketMetaInfo(symbol);
    expect(response.ok).to.be.equal(true);
  });

  it("should get market ticker data for BTC Market", async () => {
    const response = await readOnlyClient.getTickerData(symbol);
    expect(response.ok).to.be.equal(true);
  });

  it("should get master info of all markets", async () => {
    const response = await readOnlyClient.getMasterInfo();
    expect(response.ok).to.be.equal(true);
  });

  it("should get status of exchange to be alive", async () => {
    const response = await readOnlyClient.getExchangeStatus();
    expect(response.ok).to.be.equal(true);
    expect(response.data?.isAlive).to.be.equal(true);
  });

  it(`should return funding rate of ${symbol}`, async () => {
    const response = await readOnlyClient.getMarketFundingRate(symbol);
    expect(response.ok).to.be.equal(true);
  });

  describe("Sockets", () => {
    beforeEach(async () => {
      readOnlyClient.sockets.open();
      readOnlyClient.sockets.subscribeGlobalUpdatesBySymbol(symbol);
      readOnlyClient.sockets.subscribeUserUpdateByToken();
    });

    it("should receive an event for orderbook update when an order is placed on exchange", (done) => {
      const callback = ({ orderbook }: any) => {
        expect(orderbook.symbol).to.be.equal(symbol);
        done();
      };

      readOnlyClient.sockets.onOrderBookUpdate(callback);

      // wait for 1 sec as room might not had been subscribed
      setTimeout(1000).then(() => {
        client.postOrder({
          symbol,
          price: sellPrice + 3,
          quantity: 0.1,
          side: ORDER_SIDE.SELL,
          leverage: defaultLeverage,
          orderType: ORDER_TYPE.LIMIT,
        });
      });
    });

    it("should receive an event for ticker update", (done) => {
      const callback = (tickerUpdate: TickerData[]) => {
        expect(tickerUpdate.length).to.be.greaterThan(0);
        done();
      };

      readOnlyClient.sockets.onTickerUpdate(callback);
    });

    it("should receive an event when a trade is performed", (done) => {
      const callback = ({
        trades,
      }: {
        trades: GetMarketRecentTradesResponse[];
      }) => {
        expect(trades[0].symbol).to.be.equal(symbol);
        done();
      };

      readOnlyClient.sockets.onRecentTrades(callback);

      // wait for 1 sec as room might not had been subscribed
      setTimeout(1000).then(() => {
        client.postOrder({
          symbol,
          price: 0,
          quantity: 0.1,
          side: ORDER_SIDE.SELL,
          leverage: defaultLeverage,
          orderType: ORDER_TYPE.MARKET,
        });
      });
    });

    it("should receive order update event", (done) => {
      const callback = ({ order }: { order: PlaceOrderResponse }) => {
        expect(order.symbol).to.be.equal(symbol);
        done();
      };

      readOnlyClient.sockets.onUserOrderUpdate(callback);

      // wait for 1 sec as room might not had been subscribed
      setTimeout(1000).then(() => {
        client.postOrder({
          symbol,
          price: sellPrice + 1,
          quantity: 0.1,
          side: ORDER_SIDE.SELL,
          leverage: defaultLeverage,
          orderType: ORDER_TYPE.LIMIT,
        });
      });
    });

    it("should receive position update event", (done) => {
      const callback = ({ position }: { position: GetPositionResponse }) => {
        expect(position.userAddress).to.be.equal(
          readOnlyClient.getPublicAddress().toLocaleLowerCase()
        );
        done();
      };

      readOnlyClient.sockets.onUserPositionUpdate(callback);

      // wait for 1 sec as room might not had been subscribed
      setTimeout(1000).then(() => {
        client.postOrder({
          symbol,
          price: 0,
          quantity: 0.1,
          side: ORDER_SIDE.BUY,
          leverage: defaultLeverage,
          orderType: ORDER_TYPE.MARKET,
        });
      });
    });

    it("should receive user update event", (done) => {
      const callback = ({ trade }: { trade: GetUserTradesResponse }) => {
        expect(trade.maker).to.be.equal(false);
        expect(trade.symbol).to.be.equal(symbol);
        done();
      };

      readOnlyClient.sockets.onUserUpdates(callback);

      // wait for 1 sec as room might not had been subscribed
      setTimeout(1000).then(() => {
        client.postOrder({
          symbol,
          price: 0,
          quantity: 0.1,
          side: ORDER_SIDE.BUY,
          leverage: defaultLeverage,
          orderType: ORDER_TYPE.MARKET,
        });
      });
    });

    it("should receive user account update event", (done) => {
      const callback = ({
        accountData,
      }: {
        accountData: GetAccountDataResponse;
      }) => {
        expect(accountData.address).to.be.equal(
          readOnlyClient.getPublicAddress().toLocaleLowerCase()
        );
        done();
      };

      readOnlyClient.sockets.onUserAccountDataUpdate(callback);

      // wait for 1 sec as room might not had been subscribed
      setTimeout(1000).then(() => {
        client.postOrder({
          symbol,
          price: 0,
          quantity: 0.1,
          side: ORDER_SIDE.BUY,
          leverage: defaultLeverage,
          orderType: ORDER_TYPE.MARKET,
        });
      });
    });
  });

  describe("Post failure via read-only token", () => {
    it("should initialize the client with pvt and readonlytoken", async () => {
      readOnlyClient = new BluefinClient(true, network, testAcctKey);
      await readOnlyClient.init(true, readOnlyToken);
      expect(readOnlyClient).to.be.not.eq(undefined);
    });

    it("should post a LIMIT order on exchange", async () => {
      const response = await readOnlyClient.postOrder({
        symbol,
        price: buyPrice,
        quantity: 0.1,
        side: ORDER_SIDE.BUY,
        leverage: defaultLeverage,
        orderType: ORDER_TYPE.LIMIT,
        clientId: "Test limit order",
      });
      expect(response.ok).to.be.equal(false); // forbidden
    });
  });
});
import {
  Ed25519Keypair,
  Faucet,
  Keypair,
  OnChainCalls,
  Secp256k1Keypair,
  SignatureScheme,
  SignatureWithBytes,
  toBigNumberStr,
} from "@firefly-exchange/library-sui";
import fs from "fs";
import { toHex } from "@firefly-exchange/library-sui/dist/src";
import { decodeSuiPrivateKey } from "@mysten/sui/cryptography";
import deploymentData from "../deployment.json";
import CustomError from "../src/interfaces";
import { Errors } from "../src/constants";

/**
 * Generates random number
 * @param multiplier number to multiply with random number generated
 * @returns random number
 */
export const generateRandomNumber = (multiplier: number) => {
  return Math.floor((Date.now() + Math.random() + Math.random()) * multiplier);
};

export function getKeyPairFromSeed(
  seed: string,
  scheme: SignatureScheme = "Secp256k1"
): Keypair {
  switch (scheme) {
    case "ED25519":
      return Ed25519Keypair.deriveKeypair(seed);
    case "Secp256k1":
      return Secp256k1Keypair.deriveKeypair(seed);
    default:
      throw new Error("Provided scheme is invalid");
  }
}

export function getSignerFromSeed(seed: string): Keypair {
  return getKeyPairFromSeed(seed);
}

function readFileServer(filePath: string): any {
  return fs.existsSync(filePath)
    ? JSON.parse(fs.readFileSync(filePath).toString())
    : {};
}

function readFileBrowser(): any {
  return deploymentData;
}

export function readFile(filePath: string): any {
  return typeof window === "undefined"
    ? readFileServer(filePath)
    : readFileBrowser();
}

export async function setupTestAccounts(
  deployerWallet: OnChainCalls,
  testWallets: any[],
  faucetURL: string
): Promise<boolean> {
  const mintAmount = 1000000000;
  // eslint-disable-next-line no-restricted-syntax
  for (const wallet of testWallets) {
    try {
      // eslint-disable-next-line no-await-in-loop
      await Faucet.requestSUI(wallet.privateAddress, faucetURL);
    } catch (e) {
      console.log(e);
    }
  }
  // eslint-disable-next-line no-restricted-syntax
  for (const wallet of testWallets) {
    // eslint-disable-next-line no-await-in-loop
    await deployerWallet.mintUSDC({
      amount: toBigNumberStr(mintAmount.toString(), 6),
      to: wallet.privateAddress,
      gasBudget: 10000000,
    });
  }
  return true;
}

/**
 * @description
 * Generate a new wallet
 * @returns private key and public address
 * */
export function createWallet(): { privateKey: string; publicAddress: string } {
  const wallet = Ed25519Keypair.generate();
  const signerKey = wallet.getSecretKey();
  const keyPair = decodeSuiPrivateKey(signerKey);

  const publicAddress = wallet.toSuiAddress();
  return {
    privateKey: toHex(keyPair.secretKey),
    publicAddress,
  };
}

export function combineAndEncode({ bytes, signature }: SignatureWithBytes) {
  // serialize
  const separator = "||||"; // Choose a separator that won't appear in txBytes or signature
  const combinedData = `${bytes}${separator}${signature}`;

  // Encode to hex for transmission
  const encodedData = Buffer.from(combinedData, "utf-8").toString("hex");
  return encodedData;
}

/**
 * Utility function to throw a CustomError.
 *
 * @param {Error} error - The original error object.
 * @param {Errors} code - The error code.
 * @param {string} [name] - Optional custom name for the error.
 * @throws {CustomError}
 */
export function throwCustomError({
  error,
  code,
  extra,
}: {
  error: Error | string;
  code?: Errors;
  extra?: Record<any, any>;
}): never {
  if (typeof error === "string") error = new Error(error);
  throw new CustomError(error, code, extra);
}

// export async function performTrade(
//   onChain: OnChainCalls,
//   deployerSigner: RawSigner,
//   makerOrder: OrderSignatureResponse,
//   takerOrder: OrderSignatureResponse,
//   tradePrice: number
// ): Promise<[boolean, SuiTransactionBlockResponse]> {
//   const tx1 = await onChain.createSettlementOperator({
//     operator: await deployerSigner.getAddress(),
//     gasBudget: 400000000,
//   });
//   const settlementCapID = Transaction.getCreatedObjectIDs(tx1)[0];
//   // Note: Assuming deployer is already price oracle operator
//   // make admin of the exchange price oracle operator
//   const tx2 = await onChain.setPriceOracleOperator({
//     operator: await deployerSigner.getAddress(),
//     gasBudget: 400000000,
//   });
//   const updateOPCapID = Transaction.getCreatedObjectIDs(tx2)[0];

//   // set specific price on oracle
//   const tx3 = await onChain.updateOraclePrice({
//     price: toBigNumberStr(tradePrice),
//     updateOPCapID,
//     perpID: onChain.getPerpetualID(makerOrder.symbol),
//     gasBudget: 400000000,
//   });
//   let status = Transaction.getStatus(tx3);
//   const makerOnChainOrder: Order = {
//     market: onChain.getPerpetualID(makerOrder.symbol),
//     maker: makerOrder.maker,
//     isBuy: makerOrder.side === ORDER_SIDE.BUY,
//     reduceOnly: makerOrder.reduceOnly,
//     postOnly: makerOrder.postOnly,
//     orderbookOnly: makerOrder.orderbookOnly,
//     ioc: makerOrder.timeInForce === TIME_IN_FORCE.IMMEDIATE_OR_CANCEL,
//     quantity: toBigNumber(makerOrder.quantity),
//     price: toBigNumber(makerOrder.price),
//     leverage: toBigNumber(makerOrder.leverage),
//     expiration: toBigNumber(makerOrder.expiration),
//     salt: toBigNumber(makerOrder.salt),
//   };
//   const TakerOnChainOrder: Order = {
//     market: onChain.getPerpetualID(makerOrder.symbol),
//     maker: takerOrder.maker,
//     isBuy: takerOrder.side === ORDER_SIDE.BUY,
//     reduceOnly: takerOrder.reduceOnly,
//     postOnly: takerOrder.postOnly,
//     orderbookOnly: takerOrder.orderbookOnly,
//     ioc: takerOrder.timeInForce === TIME_IN_FORCE.IMMEDIATE_OR_CANCEL,
//     quantity: toBigNumber(takerOrder.quantity),
//     price: toBigNumber(takerOrder.price),
//     leverage: toBigNumber(takerOrder.leverage),
//     expiration: toBigNumber(takerOrder.expiration),
//     salt: toBigNumber(takerOrder.salt),
//   };
//   const tx = await onChain.trade({
//     makerOrder: makerOnChainOrder,
//     takerOrder: TakerOnChainOrder,
//     makerSignature: makerOrder.orderSignature,
//     takerSignature: takerOrder.orderSignature,
//     settlementCapID,
//     gasBudget: 400000000,
//     perpID: onChain.getPerpetualID(makerOrder.symbol),
//   });

//   status = Transaction.getStatus(tx);
//   if (status === "success") {
//     console.log("Transaction success");
//     return [true, tx];
//   }
//   if (status === "failure") {
//     console.log("Error:", Transaction.getError(tx));
//     return [false, tx];
//   }
//   console.log("Transaction status %s", status);
//   return [false, tx];
// }
